// =================================================================================//	CAnalysisDialog.cp				©1995 Metrowerks Inc. All rights reserved.// =================================================================================//	CAnalysisDialog.h	#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include <LStdControl.h>#include <PP_Messages.h>#include <UReanimator.h>#include "CAnalysisDialog.h"// ---------------------------------------------------------------------------------//		¥ CAnalysisDialog(LStream *)// ---------------------------------------------------------------------------------CAnalysisDialog::CAnalysisDialog(	LStream *inStream )		: LGADialog( inStream ){}// ---------------------------------------------------------------------------------//		¥ ~CAnalysisDialog// ---------------------------------------------------------------------------------CAnalysisDialog::~CAnalysisDialog(){	delete mFieldVariableList;	delete mSizer;	delete mTableSelector;	delete mTableGeometry;	delete mTableStorage;}// ---------------------------------------------------------------------------------//		¥ FinishCreateSelf// ---------------------------------------------------------------------------------voidCAnalysisDialog::FinishCreateSelf(){	// Call inherited. LDialogBox's FinishCreateSelf	// sets up the default and cancel buttons.	LGADialog::FinishCreateSelf();		// Link the dialog to the controls.	UReanimator::LinkListenerToControls( this, this, RidL_AnalysisDialog );	}const long kVariableMenuHeadingOffset = 1;voidCAnalysisDialog::ListenToMessage(	MessageT	inMessage,	void		*ioParam){	CEyeDxLongStringType theNameStr;			long theItem;		switch (inMessage) 	{				case msg_Cancel: 			// Don't have to do anything, since we didn't change the list at all						break;			case msg_OK:			// First, we have to iterate through the complete list and turn off export order for all		// variables. Then, we turn export order on for those that are in the list				long numVariables = mVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			CEyeDxVariable *theVariable = mVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the export order						theVariable->SetExportOrder(kNoExportOrder);	// Set them all to no export		}		// Now we have to do here is iterate through the list, and set each variable's export order		// to an incrementing value				numVariables = mFieldVariableList->GetCount();				for (long varNum = 1; varNum <= numVariables; varNum++)		{			CEyeDxVariable *theVariable = mFieldVariableList->GetVariableByIndex(varNum);			ThrowIfNil_(theVariable);						// Set the export order						theVariable->SetExportOrder(varNum - 1);	// Order starts at 0		}				if (mOrderChanged)		{			::ParamText("\pYou have changed the list of exported variables. EyeDx suggests you save your existing database export file before running another subject.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::CautionAlert(PPob_GeneralALRT);		}				break;			case msg_ExportOrderVarListSglClick:	case msg_ExportOrderVarListDblClick:	// We don't do anything special for double clicks			// Look up the variable that they clicked on				theItem = mTableSelector->GetFirstSelectedRow();				TableIndexT numRows;		TableIndexT numCols;				mVariableTable->GetTableSize(numRows, numCols);				mRemoveItemButton->Disable();		mMoveUpButton->Disable();		mMoveDownButton->Disable();				// If they haven't clicked on the first item, then enable the Move Up Button				if (theItem > 1)		{								mMoveUpButton->Enable();			mRemoveItemButton->Enable();		}					// And if they haven't clicked on the last item, enable the Move Down Button				if (theItem < numRows)		{			mMoveDownButton->Enable();			mRemoveItemButton->Enable();		}								break;	case msg_ExportOrderMoveUp:				// Get the item selected, and move it up in the list		theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem - 1);						// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list						UpdateVariableList(false, theItem - 1);				mOrderChanged = true;		break;	case msg_ExportOrderMoveDown:				// Get the item selected, and move it down in the list. 				theItem = mTableSelector->GetFirstSelectedRow();				// All we do is swap the entries in the list, making sure that the list is not resorted.				mFieldVariableList->SwapItems(theItem, theItem + 1);				// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list				UpdateVariableList(false, theItem + 1);		mOrderChanged = true;		break;			case msg_ExportOrderInsertVariable:		// We have to get the name of the variable from the menu. Then format it and insert it into		// the list. We insert after the current item. This is the more likely operation - appending		// items to the list, rather than inserting items before the current one.				long theItem = mVariableMenu->GetValue();				if (theItem > kVariableMenuHeadingOffset)		{			// We look up the variable by name, by retrieving the menu item text, and then			// looking up the variable. We can't just index into the variable list by index, since the			// menu changes size as the user inserts variables.						Str255 theItemStr;						MenuHandle theVariablePopupMenu = mVariableMenu->GetMacMenuH();			ThrowIfNil_( theVariablePopupMenu );			::GetMenuItemText(theVariablePopupMenu, theItem, theItemStr);						CEyeDxVariable *theVariable = mVariableList->GetVariableByName(theItemStr);						// We will insert after the current row. If the last item is selected, we will end up			// appending to the list						theItem = mTableSelector->GetFirstSelectedRow() + 1;						mFieldVariableList->InsertVariableAt(theItem, theVariable);					}				// We also set the value to the first item, which is really just a heading. We get notification		// from the menu only if the user changes the selection. Thus, we use the fake first item as a 		// placeholder - each time the user makes a selection, we process the selection and then set the		// menu value back to the first item. That ensures that we will always get notification, even if		// the user selects the same variable for insertion twice in a row.		mVariableMenu->SetValue(kVariableMenuHeadingOffset);		// Update the list and also tell the routine to update the menu. We also tell the routine to		// select the just-inserted item				UpdateVariableList(true, theItem);		mOrderChanged = true;		break;						case msg_ExportOrderRemoveItem:				theItem = mTableSelector->GetFirstSelectedRow();				mFieldVariableList->DeleteVariableByIndex(theItem);				// Update the list and also tell the routine to update the menu. We tell the routine to select		// the previous item in the list, if there is one.				if (mFieldVariableList->GetCount() > 0)		{			// We have a special case here - if the first item was deleted, we want to just select the first			// item in the list.						theItem--;			if (theItem == 0)				theItem = 1;		}		else			theItem = 0;					UpdateVariableList(true, theItem);		mOrderChanged = true;		break;						default:		break;	}	// Always pass the message on to our base class		LGADialog::ListenToMessage(inMessage, ioParam);}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------voidCAnalysisDialog::SetupDialog(CEyeDxVariableList *theVariableList){	mVariableList = theVariableList;		// Objects in the Analysis Window		mAnalysisMainView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisMainMyGWorldView ));	ThrowIfNil_( mAnalysisMainView );	mAnalysisMainViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisMainViewGroupBox ));	ThrowIfNil_( mAnalysisMainViewGroupBox );	mAnalysisUpView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisUpMyGWorldView ));	ThrowIfNil_( mAnalysisUpView );	mAnalysisUpViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisUpViewGroupBox ));	ThrowIfNil_( mAnalysisUpViewGroupBox );	mAnalysisSideView = dynamic_cast<CEyeDxViewType *> (mAnalysisWindow->FindPaneByID( kAnalysisSideMyGWorldView ));	ThrowIfNil_( mAnalysisSideView );	mAnalysisSideViewGroupBox = dynamic_cast<CEyeDxTextGroupBoxType *> (mAnalysisWindow->FindPaneByID( kAnalysisSideViewGroupBox ));	ThrowIfNil_( mAnalysisSideViewGroupBox );	mAnalysisThermometerPane = dynamic_cast<CEyeDxProgressType*> (mAnalysisWindow->FindPaneByID(kAnalysisThermometerPane));	ThrowIfNil_( mAnalysisThermometerPane );	mAnalysisProgressCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisProgressCaption));	ThrowIfNil_( mAnalysisProgressCaption );	mAnalysisProgressCaption->AddAttachment(mEraseAttachment, nil, false);		mAnalysisUpCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisUpCaption));	ThrowIfNil_( mAnalysisUpCaption );	mAnalysisUpCaption->AddAttachment(mEraseAttachment, nil, false);		mAnalysisSideCaption = dynamic_cast<CEyeDxCaptionType*> (mAnalysisWindow->FindPaneByID(kAnalysisSideCaption));	ThrowIfNil_( mAnalysisSideCaption );	mAnalysisSideCaption->AddAttachment(mEraseAttachment, nil, false);} 