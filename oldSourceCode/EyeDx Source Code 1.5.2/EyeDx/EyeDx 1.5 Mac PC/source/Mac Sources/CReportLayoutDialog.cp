// =================================================================================//	CPreferencesDialog.cp					©1996-1998 Metrowerks Inc. All rights reserved.// =================================================================================//	This file contains the starter code for the Report Layout window// members of CDocumentApp//#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <UTextTraits.h>#include <LWindow.h>#include <LGroupBox.h>#include <UResourceMgr.h>#include "EyeDxMacConstants.h"#include "CEyeDxPrefs.h"#include "DC120.h"#include <OSUtils.h>#include "CEditVariableDialog.h"#include "CExportOrderDialog.h"#include <LTextTableView.h>#include <LCellSizeToFit.h>#include <LTableSingleRowSelector.h>#include <LTableMultiGeometry.h>#include <LTableArrayStorage.h>static DCBitRate kMenuItemToBitRates[] ={	DCBitRateAuto,		// There is no item 0	DCBitRateAuto, 		// Item 1	DCBitRate57600, 	// Item 2	DCBitRate115200, 	// Item 3	DCBitRate230400		// Item 4};static void SetDefineTextCaption(LTextEditView *theTextEdit, CEyeDxCaptionType *theCaption, long selectedTextType){	switch (selectedTextType)	{	case kPreferencesHeaderText:		theCaption->SetDescriptor("\pDisplayed as bold, centered, large font");		theTextEdit->SetTextTraitsID(kBoldTimesCenteredTextTraits);		break;	case kPreferencesIntroductionText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kPreferencesPassResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kPreferencesReferResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kPreferencesRetakeResultText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kPreferencesFooterText:		theCaption->SetDescriptor("\pDisplayed as normal font");		theTextEdit->SetTextTraitsID(kNormalTimesTextTraits);		break;	case kPreferencesSessionSummaryText:		theCaption->SetDescriptor("\pSaved in summary file as monospaced font");		theTextEdit->SetTextTraitsID(kNormalMonospacedTextTraits);		break;	}}const long kNumFrozenRows = 0;const long kVariableMenuHeadingOffset = 1;void CDocumentApp::UpdateVariableList(CEyeDxVariableList *theVariableList, 									  CEyeDxBooleanType updateVariableMenu,									  CEyeDxBooleanType showHidden,									  CEyeDxVariable *reselectVariable){	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mPreferencesVariableTable->SetDeferAdjustment(true);		mPreferencesVariableTable->RemoveAllRows(true);		// Delete all of the existing rows		TableIndexT theNumberOfVariables = theVariableList->GetCount();		const UInt32 kNumVariableColumns = 5;		mPreferencesVariableTable->InsertRows((theNumberOfVariables + kNumFrozenRows), 0);	mPreferencesVariableTable->InsertCols(kNumVariableColumns, 0);	// We do not use the Frozen Rows feature, as they do not scroll horizontally! That seems to be insane,	// but that's the way it works...		//mPreferencesVariableTable->SetNumFrozenRows(1);			mPreferencesVariableTable->SetColWidth(kVariableListNameWidth, 1, 1);	mPreferencesVariableTable->SetColWidth(kVariableListClassWidth, 2, 2);	mPreferencesVariableTable->SetColWidth(kVariableListTypeWidth, 3, 3);	mPreferencesVariableTable->SetColWidth(kVariableListDataTypeWidth, 4, 4);	mPreferencesVariableTable->SetColWidth(kVariableListRequiredWidth, 5, 5);	STableCell	cell;	CEyeDxLongStringType *theStr;	CEyeDxShortStringType theTypeStr;			CEyeDxShortStringType theDataTypeStr;			// Insert the header row which is frozen		cell.row = 1;		STableCell newSelectedCell;	newSelectedCell.row = kNumFrozenRows;	newSelectedCell.col = 1;		for (cell.row = (1 + kNumFrozenRows); cell.row <= (theNumberOfVariables + kNumFrozenRows); cell.row++) 	{		// Get the variable - note that the array index is 1 based!				CEyeDxVariable *theVariable = theVariableList->GetVariableByIndex(cell.row - kNumFrozenRows);				cell.col = 1;		if (theVariable == reselectVariable)			newSelectedCell = cell;				cell.col = 1;				theStr = theVariable->GetName();				mPreferencesVariableTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());		cell.col = 2;				// If the variable is hidden, display that instead of the class				if (theVariable->GetVariableIsHidden())			theTypeStr = "\pHidden";		else		{			switch (theVariable->GetVariableClass())			{			case CEyeDxVariable::kUser:				theTypeStr = "\pUser";				break;							case CEyeDxVariable::kEyeDx:				theTypeStr = "\pEyeDx";				break;			}			}		mPreferencesVariableTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());		cell.col = 3;				switch (theVariable->GetVariableType())		{		case CEyeDxVariable::kFixed:			theTypeStr = "\pFixed";			break;					case CEyeDxVariable::kPrompted:			switch (theVariable->GetWhenToPrompt())			{			case CEyeDxVariable::kPromptNone:				theTypeStr = "\pNo Prompt";				break;							case CEyeDxVariable::kPromptOnStart:				theTypeStr = "\pPrompt: On Startup";				break;			case CEyeDxVariable::kPromptForSubject:				theTypeStr = "\pPrompt: Each Subject";				break;						case CEyeDxVariable::kPromptForSession:				theTypeStr = "\pPrompt: Each Session";				break;						case CEyeDxVariable::kPromptForEndOfSession:				theTypeStr = "\pPrompt: End of Session";				break;			case CEyeDxVariable::kPromptDisabled:				theTypeStr = "\pPrompt: Disabled";				break;			}								break;					case CEyeDxVariable::kCalculated:			theTypeStr = "\pCalculated";			break;		}		mPreferencesVariableTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());				cell.col = 4;						switch (theVariable->GetDataType())		{		case CEyeDxVariable::kTypeNone:		case CEyeDxVariable::kGeneralString:			theTypeStr = "\pString";			break;					case CEyeDxVariable::kDate:			theTypeStr = "\pDate";			break;		case CEyeDxVariable::kPastDate:			theTypeStr = "\pPast Date";			break;				case CEyeDxVariable::kTime:			theTypeStr = "\pTime";			break;				case CEyeDxVariable::kIntegerNumber:			theTypeStr = "\pNumber";			break;		case CEyeDxVariable::kCheckBox:			theTypeStr = "\pCheck Box";			break;		case CEyeDxVariable::kMenu:			theTypeStr = "\pMenu";			break;		}							mPreferencesVariableTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());				// If the variable is prompted, then indicate whether it is required or not		// If a fixed value, show the value in quotes. Otherwise, just display a blank.		cell.col = 5;						theTypeStr = "\p";				switch (theVariable->GetVariableType())		{		case CEyeDxVariable::kPrompted:			// We only show optional/required if the prompted variable isn't disabled (it would			// be confusing to say it's required if it's disabled!).						if (theVariable->GetWhenToPrompt() != CEyeDxVariable::kPromptDisabled)			{				if (theVariable->GetValueMustBeEntered())					theTypeStr = "\p(Required Entry)";				else					theTypeStr = "\p(Optional Entry)";			}			break;		case CEyeDxVariable::kFixed:			theTypeStr = "\p\"";			theStr = theVariable->GetValue();			theTypeStr += *theStr;			theTypeStr += "\p\"";			break;		}				mPreferencesVariableTable->SetCellData(cell, theTypeStr.TextPtr(), theTypeStr.Length());	}		// Since we're using a row selection object, the whole row will be selected	// when any of its cells are selected			if (newSelectedCell.row > kNumFrozenRows)	{		mPreferencesVariableTable->ScrollCellIntoFrame(newSelectedCell);	// Make sure it's visible		mPreferencesVariableTableSelector->SelectCell(newSelectedCell);	}		cell.row = 1 + kNumFrozenRows;	cell.col = 1;	mPreferencesVariableTable->SetDeferAdjustment(false);		mPreferencesVariableTable->Draw(nil);		// We can skip this if the caller isn't adding or subtracting items from the list. Speeds	// updates considerably.		if (updateVariableMenu)	{			// Now, we update the Insert Variable menu to reflect the current list		MenuHandle theVariablePopupMenu = mPreferencesVariableMenu->GetMacMenuH();		ThrowIfNil_( theVariablePopupMenu );		// Delete the current items in the list, except for the first, which is just used as a		// heading.		long nMenuItems = ::CountMItems(theVariablePopupMenu);		for (UInt16 theItemToRemove = 2; theItemToRemove <= nMenuItems; theItemToRemove++)		{			::DeleteMenuItem(theVariablePopupMenu, 2);	// Always delete the second item, which will shrink the														// menu down to just one item when we are done.		}		nMenuItems = ::CountMItems(theVariablePopupMenu);				// We use the global variable list, since we keep it in sync with the local list, and it is		// always sorted by name.				long theCount = mVariableList.GetCount();		long theMenuCount = 0;				for (long varNum = 1; varNum <= theCount; varNum++)		{			CEyeDxVariable *theListVariable = mVariableList.GetVariableByIndex(varNum);						theStr = theListVariable->GetName();			// If the advanced feature mode is on, we show everything						if (showHidden)			{				::AppendMenu(theVariablePopupMenu, *theStr);				theMenuCount++;			}			else			if (!theListVariable->GetVariableIsHidden())			{				::AppendMenu(theVariablePopupMenu, *theStr);				theMenuCount++;			}		}			// According to the PowerPlant Book, if I change the number of items in the menu		// I have to set the Max Value properly.				mPreferencesVariableMenu->SetMaxValue(theMenuCount + kVariableMenuHeadingOffset);				// We also set the value to the first item, which is really just a heading. We get notification		// from the menu only if the user changes the selection. Thus, we use the fake first item as a 		// placeholder - each time the user makes a selection, we process the selection and then set the		// menu value back to the first item. That ensures that we will always get notification, even if		// the user selects the same variable for insertion twice in a row.				mPreferences		VariableMenu->SetValue(kVariableMenuHeadingOffset);	}	StartListening();}Boolean CDocumentApp::HandlePreferences(){	Boolean theResult = false;		Handle theTemporaryTextHandles[kPreferencesNumText];	// Create the dialog handler.	StDialogHandler theHandler( PPob_PreferencesDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	Assert_( theDialog != nil );#if FALSE		CEyeDxCheckBoxType *mPreferencesAllowSpaceCheckbox = dynamic_cast<CEyeDxCheckBoxType*> (theDialog->FindPaneByID(kPreferences_AllowSpace));	ThrowIfNil_( mPreferencesAllowSpaceCheckbox );		CEyeDxPopupMenuType *mPreferencesSpaceSizeMenu;		// Display the proper size menu based on the measurement system	if (::IsMetric())		mPreferencesSpaceSizeMenu = dynamic_cast<CEyeDxPopupMenuType*> (theDialog->FindPaneByID(kPreferences_SpaceSizeMetric));	else		mPreferencesSpaceSizeMenu = dynamic_cast<CEyeDxPopupMenuType*> (theDialog->FindPaneByID(kPreferences_SpaceSizeEnglish));	ThrowIfNil_( mPreferencesSpaceSizeMenu );	mPreferencesSpaceSizeMenu->Show();#endif		// Common controls		mPreferencesTabs = dynamic_cast<CEyeDxTabsControlType*> (theDialog->FindPaneByID(kPreferences_Tabs));	ThrowIfNil_( mPreferencesTabs );	mPreferencesCancelButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kPreferences_Cancel));	ThrowIfNil_( mPreferencesCancelButton );		mPreferencesVariableMultiPanelView = dynamic_cast<LMultiPanelView*> (theDialog->FindPaneByID(kPreferences_PanelView));	ThrowIfNil_(mPreferencesVariableMultiPanelView);				mPreferencesVariableMultiPanelView->CreateAllPanels();		// General Preferences controls		mPreferencesGeneralPrefsPanel = mPreferencesVariableMultiPanelView->GetPanel(kPreferences_GeneralPrefsPanel);	ThrowIfNil_(mPreferencesGeneralPrefsPanel);			mPreferencesReportDisplayMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesReportDisplay));	ThrowIfNil_( mPreferencesReportDisplayMenu );		mPreferencesBrowserMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesReportBrowser));	ThrowIfNil_( mPreferencesBrowserMenu );		mPreferencesReportNameCheckbox = dynamic_cast<CEyeDxCheckBoxType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesReportAdjustName));	ThrowIfNil_( mPreferencesReportNameCheckbox );		mPreferencesFormatMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesReportFormat));	ThrowIfNil_( mPreferencesFormatMenu );		mPreferencesUseSessionsCheckbox = dynamic_cast<CEyeDxCheckBoxType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesUseSessions));	ThrowIfNil_( mPreferencesUseSessionsCheckbox );		mPreferencesCameraSaveFilesCheckbox = dynamic_cast<CEyeDxCheckBoxType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesCameraSaveFiles));	ThrowIfNil_( mPreferencesCameraSaveFilesCheckbox );		mPreferencesCameraSpeedMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesGeneralPrefsPanel->FindPaneByID(kPreferencesCameraRateMenu));	ThrowIfNil_( mPreferencesCameraSpeedMenu );		// Variable controls		mPreferencesVariablePanel = mPreferencesVariableMultiPanelView->GetPanel(kPreferences_VariablesPanel);	ThrowIfNil_(mPreferencesVariablePanel);		mPreferencesVariableScroller = dynamic_cast<LScrollerView*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_VariableScroller));	ThrowIfNil_( mPreferencesVariableScroller );		mPreferencesVariableTable = dynamic_cast<LTextTableView*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_VariableTable));	ThrowIfNil_( mPreferencesVariableTable );			mPreferencesNewVariableButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_VariableNew));	ThrowIfNil_( mPreferencesNewVariableButton );		mPreferencesEditVariableButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_VariableEdit));	ThrowIfNil_( mPreferencesEditVariableButton );		mPreferencesDeleteVariableButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_VariableDelete));	ThrowIfNil_( mPreferencesDeleteVariableButton );		mPreferencesPromptStyleCheckBox = dynamic_cast<CEyeDxCheckBoxType*> (mPreferencesVariablePanel->FindPaneByID(kPreferences_PromptStyle));	ThrowIfNil_( mPreferencesPromptStyleCheckBox );		// Define Text Controls		mPreferencesDefineTextPanel = mPreferencesVariableMultiPanelView->GetPanel(kPreferences_DefineTextPanel);	ThrowIfNil_(mPreferencesDefineTextPanel);		mPreferencesDefineTextMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_DefineText));	ThrowIfNil_( mPreferencesDefineTextMenu );	mPreferencesDefineTextCaption = dynamic_cast<CEyeDxCaptionType*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_DefineTextCaption));	ThrowIfNil_( mPreferencesDefineTextCaption );	mPreferencesTextEditScroller = dynamic_cast<LScrollerView*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_TextEditScroller));	ThrowIfNil_( mPreferencesTextEditScroller );		mPreferencesTextEdit = dynamic_cast<LTextEditView*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_TextEdit));	ThrowIfNil_( mPreferencesTextEdit );		mPreferencesRevertButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_Revert));	ThrowIfNil_( mPreferencesRevertButton );		mPreferencesDefaultButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_Default));	ThrowIfNil_( mPreferencesDefaultButton );		mPreferencesVariableMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesDefineTextPanel->FindPaneByID(kPreferences_InsertVariable));	ThrowIfNil_( mPreferencesVariableMenu );		// TODO CEyeDxButtonType *mPreferencesDisplaySampleButton = dynamic_cast<CEyeDxButtonType*> (theDialog->FindPaneByID(kPreferences_DisplaySample));	// TODO ThrowIfNil_( mPreferencesDisplaySampleButton );		// Database Export Controls		mPreferencesDatabasePanel = mPreferencesVariableMultiPanelView->GetPanel(kPreferences_DatabasePanel);	ThrowIfNil_(mPreferencesDatabasePanel);		mPreferencesExportedVariableTable = dynamic_cast<LTextTableView*> (mPreferencesDatabasePanel->FindPaneByID(kExportOrder_VariableTable));	ThrowIfNil_( mPreferencesExportedVariableTable );			mPreferencesExportedMoveUpButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesDatabasePanel->FindPaneByID(kExportOrder_MoveUpButton));	ThrowIfNil_( mPreferencesExportedMoveUpButton );		mPreferencesExportedMoveDownButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesDatabasePanel->FindPaneByID(kExportOrder_MoveDownButton));	ThrowIfNil_( mPreferencesExportedMoveDownButton );		mPreferencesExportedRemoveItemButton = dynamic_cast<CEyeDxButtonType*> (mPreferencesDatabasePanel->FindPaneByID(kExportOrder_RemoveItem));	ThrowIfNil_( mPreferencesExportedRemoveItemButton );		mPreferencesExportedVariableMenu = dynamic_cast<CEyeDxPopupMenuType*> (mPreferencesDatabasePanel->FindPaneByID(kExportOrder_VariableMenu));	ThrowIfNil_( mPreferencesExportedVariableMenu );		// Have the multipanel view listen to the tab control		mPreferencesTabs->AddListener(mPreferencesVariableMultiPanelView);		// And also add the Handler as a listener to the controls in the panels		UReanimator::LinkListenerToBroadcasters(&theHandler, mPreferencesGeneralPrefsPanel, PPob_GeneralPrefsPanel);	UReanimator::LinkListenerToBroadcasters(&theHandler, mPreferencesVariablePanel, PPob_VariablePanel);	UReanimator::LinkListenerToBroadcasters(&theHandler, mPreferencesDefineTextPanel, PPob_DefineTextPanel);	UReanimator::LinkListenerToBroadcasters(&theHandler, mPreferencesDatabasePanel, PPob_DatabasePanel);	// Now set up the controls		//////////////////////// Initialization for the General Prefs Panel	// Set the values of the buttons to the current selection. Since the buttons are in a button	// group, setting one will automatically turn off the other.		switch (mBrowserCreatorCode)	{	case kUnknownType:		mBrowserCreatorCode = kNetscapeCreator;				// Force the user to hit ok!				theCancelButton->Disable();		// fall through to the next case			case kNetscapeCreator:		theBrowserMenu->SetValue(kPreferencesNetscapeRB);		break;	case kExplorerCreator:		theBrowserMenu->SetValue(kPreferencesExplorerRB);		break;	}	theCameraSaveFilesCheckbox->SetValue(mCameraPrefs.saveFiles);		theCameraSaveFilesCheckbox->Enable();		// Note that we use a case statement here instead of an if statement. Eventually, there	// will be various combinations of displayOption and formatOption settings. Also note that	// the default value of the displayOption is "0" (kDisplayReport), so we can't just set the	// checkbox value to the value of the preference flag (inverted sense).		switch (mReportPrefs.displayOption)	{	case kDisplaySummary:				theReportDisplayMenu->SetValue(kPreferencesReportSummary);		break;			case kDisplayReport:				theReportDisplayMenu->SetValue(kPreferencesReportDoDisplay);		break;			case kDontDisplayReport:				theReportDisplayMenu->SetValue(kPreferencesReportNone);		break;	}		switch (mReportPrefs.adjustName)	{	case kAdjustName:				theReportNameCheckbox->SetValue(Button_On);		break;			case kDontAdjustName:				theReportNameCheckbox->SetValue(Button_Off);		break;	}		switch (mReportPrefs.formatOption)	{	case kStandardReportFormat:		theFormatMenu->SetValue(kPreferencesReportStandard);		break;	case kCustomReportFormat1:		theFormatMenu->SetValue(kPreferencesReportCustom1);		break;	}		switch (mReportPrefs.useSessions)	{	case kNoSessions:		theUseSessionsCheckbox->SetValue(Button_Off);		break;	case kUseSessions:		theUseSessionsCheckbox->SetValue(Button_On);		break;	}		// If a session is active, we don't allow them to change the status!	CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	ThrowIfNil_( theSessionNameVariable );	CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();		if (*theSessionName == CommonStringLiteral_(kDefaultSessionName))		theUseSessionsCheckbox->Enable();	else	{		CEyeDxLongStringType theLabel;				theUseSessionsCheckbox->GetDescriptor(theLabel);		theLabel.Append("\p (Session currently active)");		theUseSessionsCheckbox->SetDescriptor(theLabel);		theUseSessionsCheckbox->Disable();	}				switch (mCameraPrefs.portSpeed)	{	case DCBitRateAuto:		theCameraSpeedMenu->SetValue(1);		break;			case DCBitRate57600:		theCameraSpeedMenu->SetValue(2);		break;		case DCBitRate115200:		theCameraSpeedMenu->SetValue(3);		break;		case DCBitRate230400:		theCameraSpeedMenu->SetValue(4);		break;	default:		// For those we don't recognize, we just set the speed to Auto		theCameraSpeedMenu->SetValue(1);		break;	}		//////////////////////// Initialization for the Variable List Panel		mPreferencesVariableTable->SetCellSizer(new LCellSizeToFit(false));	mPreferencesVariableTableSelector = new LTableSingleRowSelector(mPreferencesVariableTable);		mPreferencesVariableTable->SetTableSelector(mPreferencesVariableTableSelector);		mPreferencesVariableTable->SetTableGeometry(new LTableMultiGeometry(mPreferencesVariableTable, 10, 14 ));	mPreferencesVariableTable->SetTableStorage(new LTableArrayStorage(mPreferencesVariableTable, (UInt32)0 ));	mPreferencesVariableTable->AddListener(&theHandler);	// We make our own variable list based on whether the Advanced Features mode is on. If it is,	// we show all variables (hidden and not).		CEyeDxVariableList *localVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByName);			// Copy over variables that are not hidden. Note that we save the value of the AdvancedFeatures flag	// once, here, before we create the list. That ensures that the local variable list is always correct.	// Otherwise, the user could toogle the flag in the middle of the dialog, and what's displayed in the	// table and menus would be out of whack.		CEyeDxBooleanType mShowHidden = AdvancedFeatures;		long theCount = mVariableList.GetCount();		for (long varNum = 1; varNum <= theCount; varNum++)	{		CEyeDxVariable *theListVariable = mVariableList.GetVariableByIndex(varNum);				// If the advanced feature mode is on, we show everything				if (mShowHidden)			localVariableList->AddVariable(theListVariable);		else		if (!theListVariable->GetVariableIsHidden())			localVariableList->AddVariable(theListVariable);		}	UpdateVariableList(localVariableList, true, mShowHidden);		mPreferencesEditVariableButton->SetDescriptor("\pViewÉ");	mPreferencesEditVariableButton->Disable();	mPreferencesDeleteVariableButton->Disable();	//////////////////////// Initialization for the Database Output Panel		mPreferencesExportedVariableTable->SetCellSizer(new LCellSizeToFit(false));		mPreferencesExportedVariableTableSelector = new LTableSingleRowSelector(mPreferencesExportedVariableTable);		mPreferencesExportedVariableTable->SetTableSelector(mPreferencesExportedVariableTableSelector);		mPreferencesExportedVariableTable->SetTableGeometry(new LTableMultiGeometry(mPreferencesExportedVariableTable, kVariableListNameWidth, kVariableEntryHeight));	mPreferencesExportedVariableTable->SetTableStorage(new LTableArrayStorage(mPreferencesExportedVariableTable, (UInt32)0 ));	mPreferencesExportedVariableTable->AddListener(&theHandler);	// Create our own empty variable list, using the sort by name order comparator.	// This list will hold the variables that will be output		CEyeDxVariableList *localExportedVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByExportOrder);	ThrowIfNil_(localExportedVariableList);		long numVariables = mVariableList.GetCount();		long numInList = 0;		for (long varNum = 1; varNum <= numVariables; varNum++)	{		CEyeDxVariable *theVariable = mVariableList.GetVariableByIndex(varNum);		ThrowIfNil_(theVariable);				if (theVariable->GetExportOrder() != kNoExportOrder)		{			localExportedVariableList->AddVariable(theVariable);			numInList++;		}	}		// We don't want the list to resort while the user is tweeking it		localExportedVariableList->SetKeepSorted(false);		// Update the list and also tell the routine to update the menu, plus select the last item		UpdateExportVariableList(localExportedVariableList, true, mShowHidden, numInList);		// This flag indicates whether the list has changed, so we can warn the user		CEyeDxBooleanType theExportOrderChanged = false;		// Temporarily stop listening so we don't get messages when we set the values		StopListening();#if FALSE		// If the user has requested that we allow space for letterhead, enable the space size menu		if (mReportPrefs.allowLetterHead == kNoLetterHead)		mPreferencesSpaceSizeMenu->Disable();	else		mPreferencesSpaceSizeMenu->Enable();			// TODO - need to figure out the best way to save and enter header size in a portable manner		//if (mReportPrefs.letterheadSize != 0)#endif		if (mPromptingPrefs.promptingStyle == kPromptOneAtATime)		mPreferencesPromptStyleCheckBox->SetValue(1);	else		mPreferencesPromptStyleCheckBox->SetValue(0);			// The menu items are 1..n, whereas the indexes are 0..n-1		ResID theCurrentDefineTextMenuItem = kPreferencesHeaderText;		// Set the menu item, making sure that we add one to offset to the proper menu item.		mPreferencesDefineTextMenu->SetValue(theCurrentDefineTextMenuItem + 1);		// Make copies of all of the handles for the current text, so we can revert if necessary			for (long i = 0; i < kPreferencesNumText; i++)	{			theTemporaryTextHandles[i] = mReportCustomText[i];		if (mReportCustomText[i])			::HandToHand(&theTemporaryTextHandles[i]);	}		// Put the text in the window if some exists - note that the TextEdit code copies this	// so our copy is not modified.		if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])	{		mPreferencesTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);		SetDefineTextCaption(mPreferencesTextEdit, mPreferencesDefineTextCaption, theCurrentDefineTextMenuItem);	}		StartListening();	// Activate the list box so it immediately accepts keystrokes	theDialog->SetLatentSub(mPreferencesTextEdit);		// Make the dialog visible.	theDialog->Show();		long theItem;		while ( true ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch ( theMessage)		{		case msg_Cancel:			// Free the temporary memory						for (ResID i = 0; i < kPreferencesNumText; i++)				::DisposeHandle(theTemporaryTextHandles[i]);							delete localVariableList;						delete localExportedVariableList;						return theResult;			break;#if FALSE		case  msg_PreferencesAllowSpace:			if (mPreferencesAllowSpaceCheckbox->GetValue())				mPreferencesSpaceSizeMenu->Enable();			else				mPreferencesSpaceSizeMenu->Disable();			break;		#endif		case msg_PreferencesVarListSglClick:			// Look up the variable that they clicked on						theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);							if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)				{					mPreferencesEditVariableButton->Enable();					mPreferencesEditVariableButton->SetDescriptor("\pEditÉ");					mPreferencesDeleteVariableButton->Enable();				}				else				{					mPreferencesEditVariableButton->Enable();					mPreferencesEditVariableButton->SetDescriptor("\pViewÉ");					mPreferencesDeleteVariableButton->Disable();				}					}			break;							case msg_PreferencesVarListDblClick:		case msg_PreferencesEditVariable:			// Look up the variable that they double-clicked on, or the currently-selected			// item if the Edit button was pressed, and fetch it for editing						theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);							if (theVariable->GetVariableClass() == CEyeDxVariable::kUser)				{					mPreferencesEditVariableButton->Enable();					mPreferencesEditVariableButton->SetDescriptor("\pEditÉ");					mPreferencesDeleteVariableButton->Enable();				}				else				{					mPreferencesEditVariableButton->Enable();					mPreferencesEditVariableButton->SetDescriptor("\pViewÉ");					mPreferencesDeleteVariableButton->Disable();				}						HandleEditVariable(theVariable, false, mShowHidden);				UpdateVariableList(localVariableList, true, mShowHidden, theVariable);									// Don't need to update the Export Order list, since the user isn't deleting the item			}			break;					case msg_PreferencesSortByName:			if (localVariableList->GetSortOrder() != CEyeDxVariableList::kSortByName)			{				// Get the currently selected item (if any) and reselect it after sorting				theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();								CEyeDxVariable *theVariable = nil;				if (theItem > kNumFrozenRows)					theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);				// This also forces a sort								localVariableList->SetSortOrder(CEyeDxVariableList::kSortByName);								// We pass nil as the menu handle, implying that the menu doesn't have to be redrawn.								UpdateVariableList(localVariableList, false, mShowHidden, theVariable);					// Don't need to update the Export Order list, since the user isn't deleting the item			}			break;					case msg_PreferencesSortByClass:			if (localVariableList->GetSortOrder() != CEyeDxVariableList::kSortByClass)			{				// Get the currently selected item (if any) and reselect it after sorting				theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();								CEyeDxVariable *theVariable = nil;				if (theItem > kNumFrozenRows)					theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);				// This also forces a sort								localVariableList->SetSortOrder(CEyeDxVariableList::kSortByClass);								// We pass nil as the menu handle, implying that the menu doesn't have to be redrawn.								UpdateVariableList(localVariableList, false, mShowHidden, theVariable);					// Don't need to update the Export Order list, since the user isn't deleting the item			}			break;					case msg_PreferencesSortByType:					if (localVariableList->GetSortOrder() != CEyeDxVariableList::kSortByType)			{				// Get the currently selected item (if any) and reselect it after sorting				theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();								CEyeDxVariable *theVariable = nil;				if (theItem > kNumFrozenRows)					theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);				// This also forces a sort								localVariableList->SetSortOrder(CEyeDxVariableList::kSortByType);								// We pass nil as the menu handle, implying that the menu doesn't have to be redrawn.								UpdateVariableList(localVariableList, false, mShowHidden, theVariable);					// Don't need to update the Export Order list, since the user isn't deleting the item			}			break;					case msg_PreferencesSortByDataType:					if (localVariableList->GetSortOrder() != CEyeDxVariableList::kSortByDataType)			{				// Get the currently selected item (if any) and reselect it after sorting				theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();								CEyeDxVariable *theVariable = nil;				if (theItem > kNumFrozenRows)					theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);				// This also forces a sort								localVariableList->SetSortOrder(CEyeDxVariableList::kSortByDataType);								// We pass nil as the menu handle, implying that the menu doesn't have to be redrawn.								UpdateVariableList(localVariableList, false, mShowHidden, theVariable);					// Don't need to update the Export Order list, since the user isn't deleting the item			}			break;					case msg_PreferencesNewVariable:					// Create a new variable for editing						CEyeDxVariable *theVariable = new CEyeDxVariable(CEyeDxVariable::kUser);						// Get the currently selected item (if any) and reselect it after sorting			theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();						CEyeDxVariable *thePreviousVariable = nil;			if (theItem > kNumFrozenRows)				thePreviousVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);			if (HandleEditVariable(theVariable, true, mShowHidden) == true)			{				// Add the new variable to both the local list (the one shown in the menus and scrolling list)				// and the full global list								mVariableList.AddVariable(theVariable);				localVariableList->AddVariable(theVariable);								UpdateVariableList(localVariableList, true, mShowHidden, theVariable);									// Have to update the exported variable list as well								UpdateExportVariableList(localExportedVariableList, true, mShowHidden);				mPreferencesEditVariableButton->Enable();				mPreferencesEditVariableButton->SetDescriptor("\pEditÉ");				mPreferencesDeleteVariableButton->Enable();			}			else			{				// Reselect the previously-selected item, but we don't have to update the menus as the number of items hasn't changed								UpdateVariableList(localVariableList, false, mShowHidden, thePreviousVariable);					delete theVariable;			}			break;					case msg_PreferencesDeleteVariable:					// Look up the variable that is currently selected and confirm that they want to delete it						theItem = mPreferencesVariableTableSelector->GetFirstSelectedRow();						if (theItem > kNumFrozenRows)			{										CEyeDxVariable *theVariable = localVariableList->GetVariableByIndex(theItem - kNumFrozenRows);								CEyeDxLongStringType *theName = theVariable->GetName();								::ParamText("\pAre you sure you want to delete the variable ", *theName, "\p (no undo!)?", Str_Empty);				DialogItemIndex item_hit = UModalAlerts::NoteAlert(PPob_YesNoALRT);				if (item_hit == PPob_YesNoALRT_Yes)				{					// Delete it from both the local list copy and the global copy					mVariableList.DeleteVariableByName(*theName);					localVariableList->DeleteVariableByName(*theName);										// Since they deleted the selected item, the list will have no selection					UpdateVariableList(localVariableList, true, mShowHidden);						// Have to update the exported variable list as well										UpdateExportVariableList(localExportedVariableList, true, mShowHidden);					mPreferencesEditVariableButton->Disable();					mPreferencesEditVariableButton->SetDescriptor("\pEditÉ");					mPreferencesDeleteVariableButton->Disable();				}			}						break;					case msg_PreferencesDefineText:					// We throw away the previous text for the item that is currently displayed						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])				::DisposeHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);							// Now get a copy of the TextEdit handle, and make a copy of it.						theTemporaryTextHandles[theCurrentDefineTextMenuItem] = mPreferencesTextEdit->GetTextHandle();						// Make a copy of it in our variable						::HandToHand(&theTemporaryTextHandles[theCurrentDefineTextMenuItem]);			if (::GetHandleSize(theTemporaryTextHandles[theCurrentDefineTextMenuItem]) > kWarnAboutLongOptionalFmt1Text)			{				::ParamText("\pThe number of characters you have entered may cause the report to print on more than one page.", 						"\pRun an analysis and test printing.", Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}						// Now, get the newly-selected item, and load it - remember to subtract 1 from the menu item # to get the index						theCurrentDefineTextMenuItem = mPreferencesDefineTextMenu->GetValue() - 1;						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])			{				mPreferencesTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);				SetDefineTextCaption(mPreferencesTextEdit, mPreferencesDefineTextCaption, theCurrentDefineTextMenuItem);			}			break;					case msg_PreferencesRevert:					// Just set the text back to what they had previously entered						mPreferencesTextEdit->SetTextHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);			break;					case msg_PreferencesDefault:					// Set the text to the default provided by EyeDx- don't copy it to the temporary handle,			// so the user can still revert to the previous version.						mPreferencesTextEdit->SetTextHandle(mReportDefaultText[theCurrentDefineTextMenuItem]);			break;					case msg_PreferencesInsertVariable:					// We have to get the name of the variable from the menu. Then format it and insert it into			// the text						theItem = mPreferencesVariableMenu->GetValue();						if (theItem > kVariableMenuHeadingOffset)			{				// We look up the variable, remembering that the first one is index 2. Also, we use the global				// list, looking up the variable by name. We grab the name from the selected menu item. That				// way, we don't care if the menu item list exactly matches the variable list (it won't if we				// aren't displaying hidden variables), and also doesn't matter whether list is sorted.								Str255 theName;								mPreferencesVariableMenu->GetMenuItemText(theItem, theName);								CEyeDxVariable *theVariable = mVariableList.GetVariableByName(theName);								CEyeDxLongStringType theVariableStr = "\p{";				theVariableStr.Append(theName);				theVariableStr.Append("\p}");								if ((mPreferencesTextEdit->CalcTEHeight() + theVariableStr.Length()) < max_Int16)				{					// If the user has selected some text, inserting a variable should replace that					// text. We use the clear command to erase the current selection before inserting					// the variable reference.										mPreferencesTextEdit->ObeyCommand(cmd_Clear, nil);					mPreferencesTextEdit->Insert(&theVariableStr[1], theVariableStr[0], nil, true);				}				else				{					::ParamText("\pSorry, the existing text is too long to insert that variable!", "\pPlease shorten the text and try again.", Str_Empty, Str_Empty);					UModalAlerts::StopAlert(PPob_GeneralALRT);				}								// We also set the value to the first item, which is really just a heading. We get notification				// from the menu only if the user changes the selection. Thus, we use the fake first item as a 				// placeholder - each time the user makes a selection, we process the selection and then set the				// menu value back to the first item. That ensures that we will always get notification, even if				// the user selects the same variable for insertion twice in a row.						mPreferencesVariableMenu->SetValue(kVariableMenuHeadingOffset);			}				break;					case msg_ExportOrderVarListSglClick:		case msg_ExportOrderVarListDblClick:					// Look up the variable that they clicked on						theItem = mPreferencesExportedVariableTableSelector->GetFirstSelectedRow();						TableIndexT numRows;			TableIndexT numCols;						mPreferencesExportedVariableTable->GetTableSize(numRows, numCols);						mPreferencesExportedRemoveItemButton->Disable();			mPreferencesExportedMoveUpButton->Disable();			mPreferencesExportedMoveDownButton->Disable();						// If they haven't clicked on the first item, then enable the Move Up Button						if (theItem > 1)			{									mPreferencesExportedMoveUpButton->Enable();				mPreferencesExportedRemoveItemButton->Enable();			}							// And if they haven't clicked on the last item, enable the Move Down Button						if (theItem < numRows)			{				mPreferencesExportedMoveDownButton->Enable();				mPreferencesExportedRemoveItemButton->Enable();			}			break;					case msg_ExportOrderMoveUp:						// Get the item selected, and move it up in the list			theItem = mPreferencesExportedVariableTableSelector->GetFirstSelectedRow();						// All we do is swap the entries in the list, making sure that the list is not resorted.						localExportedVariableList->SwapItems(theItem, theItem - 1);								// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of			// items in the list								UpdateExportVariableList(localExportedVariableList, false, mShowHidden, theItem - 1);						theExportOrderChanged = true;						break;		case msg_ExportOrderMoveDown:							// Get the item selected, and move it down in the list. 						theItem = mPreferencesExportedVariableTableSelector->GetFirstSelectedRow();						// All we do is swap the entries in the list, making sure that the list is not resorted.						localExportedVariableList->SwapItems(theItem, theItem + 1);						// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of			// items in the list						UpdateExportVariableList( localExportedVariableList, false, mShowHidden, theItem + 1);			theExportOrderChanged = true;						break;				case msg_ExportOrderInsertVariable:			// We have to get the name of the variable from the menu. Then format it and insert it into			// the list. We insert after the current item. This is the more likely operation - appending			// items to the list, rather than inserting items before the current one.						long theItem = mPreferencesExportedVariableMenu->GetValue();						if (theItem > kVariableMenuHeadingOffset)			{				// We look up the variable by name, by retrieving the menu item text, and then				// looking up the variable. We can't just index into the variable list by index, since the				// menu changes size as the user inserts variables.								Str255 theItemStr;								MenuHandle theVariablePopupMenu = mPreferencesExportedVariableMenu->GetMacMenuH();				ThrowIfNil_( theVariablePopupMenu );				::GetMenuItemText(theVariablePopupMenu, theItem, theItemStr);								CEyeDxVariable *theVariable = mVariableList.GetVariableByName(theItemStr);								// We will insert after the current row. If the last item is selected, we will end up				// appending to the list								theItem = mPreferencesExportedVariableTableSelector->GetFirstSelectedRow() + 1;								localExportedVariableList->InsertVariableAt(theItem, theVariable);							// Update the list and also tell the routine to update the menu. We also tell the routine to				// select the just-inserted item								UpdateExportVariableList(localExportedVariableList, true, mShowHidden, theItem);				theExportOrderChanged = true;			}						break;					case msg_ExportOrderRemoveItem:						theItem = mPreferencesExportedVariableTableSelector->GetFirstSelectedRow();						localExportedVariableList->DeleteVariableByIndex(theItem);						// Update the list and also tell the routine to update the menu. We tell the routine to select			// the previous item in the list, if there is one.						if (localExportedVariableList->GetCount() > 0)			{				// We have a special case here - if the first item was deleted, we want to just select the first				// item in the list.								theItem--;				if (theItem == 0)					theItem = 1;			}			else				theItem = 0;							UpdateExportVariableList(localExportedVariableList, true, mShowHidden, theItem);			theExportOrderChanged = true;			break;							case msg_OK:			theResult = true;#if FALSE			if (mPreferencesAllowSpaceCheckbox->GetValue())				mReportPrefs.allowLetterHead = kAllowLetterHead;			else				mReportPrefs.allowLetterHead = kNoLetterHead;#endif											// We throw away the previous text for the item that is currently displayed						if (theTemporaryTextHandles[theCurrentDefineTextMenuItem])				::DisposeHandle(theTemporaryTextHandles[theCurrentDefineTextMenuItem]);							// Now get a copy of the TextEdit handle, and make a copy of it.						theTemporaryTextHandles[theCurrentDefineTextMenuItem] = mPreferencesTextEdit->GetTextHandle();						// Make a copy of it in our variable						::HandToHand(&theTemporaryTextHandles[theCurrentDefineTextMenuItem]);			if (::GetHandleSize(theTemporaryTextHandles[theCurrentDefineTextMenuItem]) > kWarnAboutLongOptionalFmt1Text)			{				::ParamText("\pThe number of characters you have entered may cause the report to print on more than one page.", 						"\pRun an analysis and test printing.", Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}						// Now, save all of the text blocks.						// For each of the text block types, discard the previous text, and save the new text						ResID theResourceID = kSampleReportHeaderTextID;						for (ResID i = 0; i < kPreferencesNumText; i++, theResourceID++)			{				// Discard the previous custom text handle if one exists								if (mReportCustomText[i])					::DisposeHandle(mReportCustomText[i]);							mReportCustomText[i] = theTemporaryTextHandles[i];							// No need to copy it, since it already is a copy! Just save it in the preferences 								mPreferences->SaveReportTextPrefs(mReportCustomText[i], theResourceID);			}						if (mPreferencesPromptStyleCheckBox->GetValue() == 1)				mPromptingPrefs.promptingStyle = kPromptOneAtATime;			else				mPromptingPrefs.promptingStyle = kPromptAllInOne;				// Now, we have to iterate through the complete list and turn off export order for all			// variables. Then, we turn export order on for those that are in the export order list						long numVariables = mVariableList.GetCount();						for (long varNum = 1; varNum <= numVariables; varNum++)			{				CEyeDxVariable *theVariable = mVariableList.GetVariableByIndex(varNum);				ThrowIfNil_(theVariable);								// Set the export order								theVariable->SetExportOrder(kNoExportOrder);	// Set them all to no export			}			// Now we have to do here is iterate through the list, and set each variable's export order			// to an incrementing value						numVariables = localExportedVariableList->GetCount();						for (long varNum = 1; varNum <= numVariables; varNum++)			{				CEyeDxVariable *theVariable = localExportedVariableList->GetVariableByIndex(varNum);				ThrowIfNil_(theVariable);								// Set the export order								theVariable->SetExportOrder(varNum - 1);	// Order starts at 0			}						if (theExportOrderChanged)			{				::ParamText("\pYou have changed the list of exported variables. EyeDx suggests you save your existing database export file before running another subject.", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::CautionAlert(PPob_GeneralALRT);			}			// Free the temporary memory						delete localVariableList;						delete localExportedVariableList;						mPreferences->SavePromptingPrefs(&mPromptingPrefs);							mPreferences->SaveReportPrefs(&mReportPrefs);										mPreferences->SaveVariablePrefs(&mVariableList);						return theResult;						break;		}	}	return theResult;}Boolean CDocumentApp::HandleEditVariable(CEyeDxVariable *theVariable, CEyeDxBooleanType newVariable, CEyeDxBooleanType showHidden){	// Create the dialog handler.	StDialogHandler theHandler( PPob_EditVariableDialog, this );	// Get the dialog.	CEditVariableDialog *theDialog;	theDialog = dynamic_cast<CEditVariableDialog *>(theHandler.GetDialog());	ThrowIfNil_(theDialog);		theDialog->SetupDialog(&mVariableList, theVariable, newVariable, showHidden);		// Make the dialog visible.	theDialog->Show();		CEyeDxBooleanType done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:			return false;			break;		case msg_OK:			if (theDialog->UserInputValid())			{				return true;			}			// Otherwise, we keep the dialog up and DON'T return			break;		}	}	return false;}voidCDocumentApp::UpdateExportVariableList(CEyeDxVariableList *theExportedVariableList, CEyeDxBooleanType updateMenuAsWell, CEyeDxBooleanType showHidden, long itemToSelect){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	StopListening();	// Set the list to allow only one item to be selected	// This will defer updating the table until we exit the routine, saving a lot of redraws		mPreferencesExportedVariableTable->SetDeferAdjustment(true);		// Delete all of the existing rows		mPreferencesExportedVariableTable->RemoveAllRows(true);		// Figure out how many prompted variables there are	TableIndexT theNumberOfVariables = theExportedVariableList->GetCount();		mPreferencesExportedVariableTable->InsertRows(theNumberOfVariables, 0);	const UInt32 kNumVariableColumns = 1;		mPreferencesExportedVariableTable->InsertCols(kNumVariableColumns, 0);		mPreferencesExportedVariableTable->SetColWidth(kVariableListNameWidth, 1, 1);	STableCell	cell;	CEyeDxLongStringType *theStr;		cell.col = 1;			for (cell.row = 1; cell.row <= theNumberOfVariables; cell.row++) 	{		// Get the variable - note that the array index is 1 based!				CEyeDxVariable *theVariable = theExportedVariableList->GetVariableByIndex(cell.row);				theStr = theVariable->GetName();				mPreferencesExportedVariableTable->SetCellData(cell, theStr->TextPtr(), theStr->Length());	}		mPreferencesExportedVariableTable->SetDeferAdjustment(false);		if (theNumberOfVariables == 0)		mPreferencesExportedRemoveItemButton->Disable();		if (itemToSelect > 0)	{		cell.row = itemToSelect;				mPreferencesExportedVariableTableSelector->SelectCell(cell);		mPreferencesExportedVariableTable->ScrollCellIntoFrame(cell);	// Make sure it's visible		// Now update the Move Up and Down buttons				mPreferencesExportedMoveUpButton->Disable();		mPreferencesExportedMoveDownButton->Disable();				// If the the selected item isn't the first item, then enable the Move Up Button				if (itemToSelect > 1)									mPreferencesExportedMoveUpButton->Enable();					// And if the selected item isn't the last item, enable the Move Down Button				if (itemToSelect < theNumberOfVariables)			mPreferencesExportedMoveDownButton->Enable();					mPreferencesExportedRemoveItemButton->Enable();								}	else	{		mPreferencesExportedMoveUpButton->Disable();		mPreferencesExportedMoveDownButton->Disable();			}		mPreferencesExportedVariableTable->Draw(nil);		if (updateMenuAsWell)	{			// Now, we update the Insert Variable menu to reflect the current list, which is the list of available		// variables minus the variables already selected		MenuHandle theVariablePopupMenu = mPreferencesExportedVariableMenu->GetMacMenuH();		ThrowIfNil_( theVariablePopupMenu );		// Delete the current items in the list, except for the first, which is just used as a		// heading.		long nMenuItems = ::CountMItems(theVariablePopupMenu);		for (UInt16 theItemToRemove = 2; theItemToRemove <= nMenuItems; theItemToRemove++)		{			::DeleteMenuItem(theVariablePopupMenu, 2);	// Always delete the second item, which will shrink the														// menu down to just one item when we are done.		}		long theNumberOfVariables = mVariableList.GetCount();				long theActualNumberOfItems = 0;		// Now add the list of variables, but only if each variable isn't already in the theExportedVariableList		for (long theItemToAdd = 1; theItemToAdd <= theNumberOfVariables; theItemToAdd++)		{			CEyeDxVariable *theVariable = mVariableList.GetVariableByIndex(theItemToAdd);						theStr = theVariable->GetName();						if (theExportedVariableList->GetVariableByName(*theStr) == NULL)			{				if (showHidden)				{					::AppendMenu(theVariablePopupMenu, *theStr);					theActualNumberOfItems++;				}				else				if (!theVariable->GetVariableIsHidden())				{					::AppendMenu(theVariablePopupMenu, *theStr);					theActualNumberOfItems++;				}			}		}		// According to the PowerPlant Book, if I change the number of items in the menu		// I have to set the Max Value properly.				mPreferencesExportedVariableMenu->SetMaxValue(theActualNumberOfItems + kVariableMenuHeadingOffset);				// We also set the value to the first item, which is really just a heading. We get notification		// from the menu only if the user changes the selection. Thus, we use the fake first item as a 		// placeholder - each time the user makes a selection, we process the selection and then set the		// menu value back to the first item. That ensures that we will always get notification, even if		// the user selects the same variable for insertion twice in a row.				mPreferencesExportedVariableMenu->SetValue(kVariableMenuHeadingOffset);	}		StartListening();}