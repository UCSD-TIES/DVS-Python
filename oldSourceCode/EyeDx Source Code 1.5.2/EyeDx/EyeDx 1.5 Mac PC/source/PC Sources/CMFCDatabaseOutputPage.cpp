// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifIMPLEMENT_DYNCREATE(CMFCDatabaseOutputPage, CPropertyPage)BEGIN_MESSAGE_MAP( CMFCDatabaseOutputPage, CPropertyPage )ON_BN_CLICKED(IDC_DEFINEEXPORTORDER_MOVEUPBUTTON, OnMoveUpPressed)ON_BN_CLICKED(IDC_DEFINEEXPORTORDER_MOVEDOWNBUTTON, OnMoveDownPressed)ON_CBN_SELENDOK(IDC_DEFINEEXPORTORDER_VARIABLEMENU, OnInsertPressed)ON_BN_CLICKED(IDC_DEFINEEXPORTORDER_REMOVEBUTTON, OnRemovePressed)ON_LBN_SELCHANGE(IDC_DEFINEEXPORTORDER_VARIABLELIST, OnVariableListClicked)ON_WM_SIZE()END_MESSAGE_MAP()CEyeDxBooleanType CMFCDatabaseOutputPage::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}const long kVariabletringWidth = 182;void CMFCDatabaseOutputPage::OnOK(){	// First, we have to iterate through the complete list and turn off export order for all	// variables. Then, we turn export order on for those that are in the list		long numVariables = m_VariableList->GetCount();		for (long varNum = 0; varNum < numVariables; varNum++)	{		CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(varNum);				// Set the export order				theVariable->SetExportOrder(kNoExportOrder);	// Set them all to no export	}	// All we have to do here is iterate through the list, and set each variable's prompt order	// to an incrementing value		numVariables = m_FieldVariableList->GetCount();		for (long varNum = 0; varNum < numVariables; varNum++)	{		CEyeDxVariable *theVariable = m_FieldVariableList->GetVariableByIndex(varNum);				// Set the export order				theVariable->SetExportOrder(varNum);	// Order starts at 0	}		if (m_OrderChanged)	{		CancelToClose();		MessageBox("You have changed the list of exported variables. EyeDx suggests you save your existing database export file before running another subject.", AfxGetAppName());	}}		void CMFCDatabaseOutputPage::OnVariableListClicked(){			// Look up the item that they clicked on		int theItem = m_VariableTable->GetCurSel();		if (theItem != CB_ERR)	{			int numItems = m_VariableTable->GetCount();					m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);		m_RemoveItemButton->EnableWindow(FALSE);				// If they haven't clicked on the first item, then enable the Move Up Button				if (theItem > 0)		{								m_MoveUpButton->EnableWindow(TRUE);			m_RemoveItemButton->EnableWindow(TRUE);		}				// And if they haven't clicked on the last item, enable the Move Down Button				if (theItem < (numItems - 1))		{			m_MoveDownButton->EnableWindow(TRUE);			m_RemoveItemButton->EnableWindow(TRUE);		}				}}void CMFCDatabaseOutputPage::OnMoveUpPressed(){			// Get the item selected, and move it up in the list	int theItem = m_VariableTable->GetCurSel();		if (theItem != CB_ERR)	{			// All we do is swap the entries in the list, making sure that the list is not resorted.				m_FieldVariableList->SwapItems(theItem - 1, theItem);				// Update the list						UpdateVariableList(FALSE, theItem - 1);				m_OrderChanged = TRUE;	}}		void CMFCDatabaseOutputPage::OnMoveDownPressed(){					// Get the item selected, and move it down in the list. 		int theItem = m_VariableTable->GetCurSel();		if (theItem != CB_ERR)	{			// All we do is swap the entries in the list, making sure that the list is not resorted.				m_FieldVariableList->SwapItems(theItem + 1, theItem);					// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list				UpdateVariableList(FALSE, theItem + 1);		m_OrderChanged = TRUE;	}}		void CMFCDatabaseOutputPage::OnInsertPressed(){					// We have to get the name of the variable from the menu. Then format it and insert it into	// the list. We insert after the current item. This is the more likely operation - appending	// items to the list, rather than inserting items before the current one.		long theItem = m_VariableMenu->GetCurSel();		if (theItem != CB_ERR)	{			// We look up the variable by name, by retrieving the menu item text, and then		// looking up the variable. We can't just index into the variable list by index, since the		// menu changes size as the user inserts variables.				CEyeDxLongStringType theItemStr;				m_VariableMenu->GetLBText(theItem, theItemStr);				CEyeDxVariable *theVariable = m_VariableList->GetVariableByName(theItemStr);				// We will insert after the current row. If the last item is selected, we will end up		// appending to the list				theItem = m_VariableTable->GetCurSel() + 1;				m_FieldVariableList->InsertVariableAt(theItem, theVariable);							UpdateVariableList(TRUE, theItem);		m_OrderChanged = TRUE;	}}		void CMFCDatabaseOutputPage::OnRemovePressed(){					int theItem = m_VariableTable->GetCurSel();		if (theItem != CB_ERR)	{			m_FieldVariableList->DeleteVariableByIndex(theItem);			if (m_FieldVariableList->GetCount() > 0)		{			// We have a special case here - if the first item was deleted, we want to just select the first			// item in the list.						theItem--;			if (theItem < 0)				theItem = 0;		}		else			theItem = -1;					UpdateVariableList(TRUE, theItem);		m_OrderChanged = true;	}}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------intCMFCDatabaseOutputPage::OnInitDialog(){#ifdef DEBUG_PROPERTIESAfxMessageBox("E1", IDOK);#endif	CPropertyPage::OnInitDialog();#ifdef DEBUG_PROPERTIESAfxMessageBox("E2", IDOK);#endif	m_VariableTable = (CListBox *) GetDlgItem((IDC_DEFINEEXPORTORDER_VARIABLELIST));			m_MoveUpButton = (CButton *) GetDlgItem((IDC_DEFINEEXPORTORDER_MOVEUPBUTTON));		m_MoveDownButton = (CButton *) GetDlgItem((IDC_DEFINEEXPORTORDER_MOVEDOWNBUTTON));		m_RemoveItemButton = (CButton *) GetDlgItem((IDC_DEFINEEXPORTORDER_REMOVEBUTTON));		m_VariableMenu = (CComboBox *) GetDlgItem((IDC_DEFINEEXPORTORDER_VARIABLEMENU));	#ifdef DEBUG_PROPERTIESAfxMessageBox("E3", IDOK);#endif	// Create our own empty variable list.	// This list will hold the variables that will be output		m_FieldVariableList = new CEyeDxVariableList(CEyeDxVariableList::kSortByExportOrder);		CEyeDxVariable *theVariable;	short theExportOrder = kNoExportOrder;	int numInList = 0;		// We add variables in the order in which they appear in export order	while ((theVariable = m_VariableList->GetNextExportedVariable(theExportOrder)) != NULL)	{		m_FieldVariableList->AddVariable(theVariable);		theExportOrder = theVariable->GetExportOrder();		numInList++;	}		#ifdef DEBUG_PROPERTIESAfxMessageBox("E4", IDOK);#endif	// Update the list and also tell the routine to update the menu, plus select the last item		UpdateVariableList(TRUE, numInList - 1);		// This flag indicates whether the list has changed, so we can warn the user		m_OrderChanged = FALSE;#ifdef DEBUG_PROPERTIESAfxMessageBox("E5", IDOK);#endif	// Finally, add all of the controls to the resizer object		m_Resizer.Add(this, IDC_DEFINEEXPORTORDER_VARIABLELIST, RESIZE_LOCKLEFT | RESIZE_LOCKTOP | RESIZE_LOCKBOTTOM);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDER_MOVEUPBUTTON, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDER_MOVEDOWNBUTTON, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDER_REMOVEBUTTON,  RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDER_VARIABLEMENU,   RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDERINSERTLABEL, RESIZE_LOCKLEFT | RESIZE_LOCKTOP);	m_Resizer.Add(this, IDC_DEFINEEXPORTORDERGB, RESIZE_LOCKLEFT | RESIZE_LOCKTOP | RESIZE_LOCKBOTTOM);#ifdef DEBUG_PROPERTIESAfxMessageBox("E6", IDOK);#endif	return TRUE;} void CMFCDatabaseOutputPage::OnSize(UINT nType, int cx, int cy) {	CPropertyPage::OnSize(nType, cx, cy);	// Resize!	m_Resizer.Resize(this);	}BOOL CMFCDatabaseOutputPage::OnSetActive(){	if (!CPropertyPage::OnSetActive())		return FALSE;		// Anytime our page becomes active, we update the menu so that it reflects	// the current list of variables		UpdateVariableList(true, -1);		return TRUE;}voidCMFCDatabaseOutputPage::UpdateVariableList(CEyeDxBooleanType updateMenuAsWell, long itemToSelect){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	m_VariableTable->ResetContent();		// Figure out how many Variable there are	int theNumberOfVariable = m_FieldVariableList->GetCount();			for (int theItem = 0; theItem < theNumberOfVariable; theItem++)	{		CEyeDxVariable *theVariable = m_FieldVariableList->GetVariableByIndex(theItem);				CEyeDxShortStringType *theString = theVariable->GetName();			m_VariableTable->AddString(*theString);	}				if (theNumberOfVariable == 0)		m_RemoveItemButton->EnableWindow(FALSE);	if (itemToSelect >= 0)	{		m_VariableTable->SetCurSel(itemToSelect);	// Make sure it's visible		// Now update the Move Up and Down buttons				m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);				// If the the selected item isn't the first item, then enable the Move Up Button				if (itemToSelect > 0)									m_MoveUpButton->EnableWindow(TRUE);					// And if the selected item isn't the last item, enable the Move Down Button				if (itemToSelect < theNumberOfVariable - 1)			m_MoveDownButton->EnableWindow(TRUE);		m_RemoveItemButton->EnableWindow(TRUE);	}	else	{		m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);			}		if (updateMenuAsWell)	{		m_VariableMenu->ResetContent();				long numVariables = m_VariableList->GetCount();				for (long varNum = 0; varNum < numVariables; varNum++)		{			CEyeDxVariable *theVariable = m_VariableList->GetVariableByIndex(varNum);						CEyeDxLongStringType *theStr = theVariable->GetName();						if (m_FieldVariableList->GetVariableByName(*theStr) == NULL)				m_VariableMenu->AddString(*theStr);		}	}}void CMFCDatabaseOutputPage::DoDataExchange(CDataExchange *pDX){	CPropertyPage::DoDataExchange(pDX);}