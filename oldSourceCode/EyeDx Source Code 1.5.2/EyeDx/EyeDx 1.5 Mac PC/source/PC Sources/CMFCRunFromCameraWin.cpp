// main.cp#include "main.h"static LPCTSTR lpszWindowName="Run From Camera";extern CMainApp gMainApp;CMFCRunFromCameraWin::CMFCRunFromCameraWin(CRect *posRect, CMainWindow *myParent, 						CEyeDxBooleanType *DirectorySetPtr, char *DefaultImagesDir, 						DCPortNum *pPortNum, DCBitRate pConnectionRate)						: CMFCRunWin(posRect, myParent, DirectorySetPtr, DefaultImagesDir){	// This variable prevents certain drawing operations from occurring before	// we are really initialized. This include the OnSetFocus call.		initialized = FALSE;		m_PortNum = pPortNum;	m_ConnectionRate = pConnectionRate;		// This creates the Run From Camera window			CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);}BEGIN_MESSAGE_MAP( CMFCRunFromCameraWin, CMFCRunWin )ON_MESSAGE(EYEDX_MFC_START_CAMERA_MESSAGE, StartCamera)ON_BN_CLICKED(IDC_CAMERA_OK, 	OnOkButtonClicked)ON_BN_CLICKED(IDCANCEL, 	OnCancelButtonClicked)ON_BN_CLICKED(IDC_CAMERA_SELECT_UP_BUTTON, 	OnSelectUpButtonClicked)ON_BN_CLICKED(IDC_CAMERA_SELECT_SIDE_BUTTON, 	OnSelectSideButtonClicked)ON_BN_CLICKED(IDC_CAMERA_ANIMATE_CHECKBOX, OnAnimateCheckboxClicked)ON_BN_CLICKED(IDC_CAMERA_UP_ZOOM_BUTTON, OnUpZoomButtonClicked)ON_BN_CLICKED(IDC_CAMERA_SIDE_ZOOM_BUTTON, OnSideZoomButtonClicked)ON_WM_SETFOCUS()ON_WM_CREATE()END_MESSAGE_MAP()CEyeDxBooleanType CMFCRunFromCameraWin::PreTranslateMessage(MSG *pMsg){	if (IsDialogMessage(pMsg) == TRUE)		return TRUE;	else if (CWnd::PreTranslateMessage(pMsg) == TRUE)		return TRUE;	else 		return FALSE;}void CMFCRunFromCameraWin::OnSetFocus(CWnd *pOldWnd){	CWnd::OnSetFocus(pOldWnd);	//m_ctlUpSelectButton.SetButtonStyle(m_ctlUpSelectButton.GetButtonStyle() | BS_DEFPUSHBUTTON);	if (initialized)		m_ctlUpSelectButton.SetFocus();}int CMFCRunFromCameraWin::OnCreate(LPCREATESTRUCT lpcs){	if (CMFCRunWin::OnCreate(lpcs) == -1)		return -1;			RunInProgress = 1;			CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (CAMERA_VIEW_WIDTH / 2) + CAMERA_RIGHT_MARGIN - (CAMERA_CENTER_GAP / 3);		int RightCenterLine = WindowWidth - CAMERA_RIGHT_MARGIN - (CAMERA_VIEW_WIDTH / 2) + (CAMERA_CENTER_GAP / 3);			// Up Progress caption		rect.SetRect(m_cxChar * CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine) + CAMERA_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_UP_PROGRESS_CAPTION_Y + CAMERA_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + CAMERA_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_SIDE_PROGRESS_CAPTION_Y + CAMERA_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_PROGRESS_BAR_Y, 				 m_cxChar * (CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine) + CAMERA_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (CAMERA_UP_PROGRESS_BAR_Y + CAMERA_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_CAMERA_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine) + CAMERA_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (CAMERA_SIDE_PROGRESS_BAR_Y + CAMERA_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_CAMERA_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * CAMERA_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_VIEW_Y, 				 m_cxChar * (CAMERA_UP_VIEW_X(LeftCenterLine) + CAMERA_UP_VIEW_WIDTH), 				 m_cyChar * (CAMERA_UP_VIEW_Y + CAMERA_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_CAMERA_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * CAMERA_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_VIEW_Y, 				 m_cxChar * (CAMERA_SIDE_VIEW_X(RightCenterLine) + CAMERA_SIDE_VIEW_WIDTH), 				 m_cyChar * (CAMERA_SIDE_VIEW_Y + CAMERA_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_CAMERA_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * CAMERA_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_QUALITY_ICON_Y, 				 m_cxChar * (CAMERA_UP_QUALITY_ICON_X(LeftCenterLine) + CAMERA_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (CAMERA_UP_QUALITY_ICON_Y + CAMERA_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_CAMERA_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine) + CAMERA_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (CAMERA_SIDE_QUALITY_ICON_Y + CAMERA_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_CAMERA_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Top of Head Bitmap	rect.SetRect(m_cxChar * CAMERA_SIDE_TOP_OF_HEAD_BITMAP_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_TOP_OF_HEAD_BITMAP_Y, 				 m_cxChar * (CAMERA_SIDE_TOP_OF_HEAD_BITMAP_X(RightCenterLine) + CAMERA_SIDE_TOP_OF_HEAD_BITMAP_WIDTH), 				 m_cyChar * (CAMERA_SIDE_TOP_OF_HEAD_BITMAP_Y + CAMERA_SIDE_TOP_OF_HEAD_BITMAP_HEIGHT));		m_ctlSideTopOfHeadBitmap.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP, rect, this, IDC_CAMERA_SIDE_TOP_OF_HEAD_BITMAP);	m_ctlSideTopOfHeadBitmap.SetBitmap(m_hTopOfHeadSidewaysBitmap);	// Up Image caption		rect.SetRect(m_cxChar * CAMERA_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_CAPTION_Y, 				 m_cxChar * (CAMERA_UP_CAPTION_X(LeftCenterLine) + CAMERA_UP_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_UP_CAPTION_Y + CAMERA_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * CAMERA_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_CAPTION_Y, 				 m_cxChar * (CAMERA_SIDE_CAPTION_X(RightCenterLine) + CAMERA_SIDE_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_SIDE_CAPTION_Y + CAMERA_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// The Zoom Buttons - note that the calculations have to use the actual Bitmap width and height, and thus	// cannot be scaled by the character cell sizes.		rect.SetRect((m_cxChar * (CAMERA_UP_VIEW_X(LeftCenterLine) + CAMERA_UP_VIEW_WIDTH)) - CAMERA_UP_ZOOM_BUTTON_WIDTH, 				 m_cyChar * CAMERA_UP_ZOOM_BUTTON_Y, 				 (m_cxChar * (CAMERA_UP_VIEW_X(LeftCenterLine) + CAMERA_UP_VIEW_WIDTH)), 				 (m_cyChar * CAMERA_UP_ZOOM_BUTTON_Y) + CAMERA_UP_ZOOM_BUTTON_HEIGHT);		m_ctlUpZoomButton.Create(CAMERA_UP_ZOOM_BUTTON_LABEL, 				WS_CHILD  | WS_TABSTOP | BS_OWNERDRAW, rect, this, IDC_CAMERA_UP_ZOOM_BUTTON);	m_ctlUpZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);		rect.SetRect((m_cxChar * (CAMERA_SIDE_VIEW_X(RightCenterLine) + CAMERA_SIDE_VIEW_WIDTH)) - CAMERA_SIDE_ZOOM_BUTTON_WIDTH, 				 m_cyChar * CAMERA_SIDE_ZOOM_BUTTON_Y, 				 (m_cxChar * (CAMERA_SIDE_VIEW_X(RightCenterLine) + CAMERA_SIDE_VIEW_WIDTH)), 				 (m_cyChar * CAMERA_SIDE_ZOOM_BUTTON_Y) + CAMERA_SIDE_ZOOM_BUTTON_HEIGHT);		m_ctlSideZoomButton.Create(CAMERA_SIDE_ZOOM_BUTTON_LABEL, 				WS_CHILD  | WS_TABSTOP | BS_OWNERDRAW, rect, this, IDC_CAMERA_SIDE_ZOOM_BUTTON);	m_ctlSideZoomButton.LoadBitmaps("ZoomButtonU", "ZoomButtonD", "ZoomButtonF", NULL);		// Select Up Image button			rect.SetRect(m_cxChar * CAMERA_SELECT_UP_BUTTON_X(LeftCenterLine), 				 m_cyChar * CAMERA_SELECT_UP_BUTTON_Y, 				 m_cxChar * (CAMERA_SELECT_UP_BUTTON_X(LeftCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_SELECT_UP_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlUpSelectButton.Create(CAMERA_SELECT_UP_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_CAMERA_SELECT_UP_BUTTON);	// Select Side Image button		rect.SetRect(m_cxChar * CAMERA_SELECT_SIDE_BUTTON_X(RightCenterLine), 				 m_cyChar * CAMERA_SELECT_SIDE_BUTTON_Y, 				 m_cxChar * (CAMERA_SELECT_SIDE_BUTTON_X(RightCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_SELECT_SIDE_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlSideSelectButton.Create(CAMERA_SELECT_SIDE_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_CAMERA_SELECT_SIDE_BUTTON);	// Show Animation during processing checkbox		rect.SetRect(m_cxChar * CAMERA_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * CAMERA_ANIMATE_CHECKBOX_Y, 				 m_cxChar * (CAMERA_ANIMATE_CHECKBOX_X(CenterLine) + CAMERA_ANIMATE_CHECKBOX_WIDTH), 				 m_cyChar * (CAMERA_ANIMATE_CHECKBOX_Y + CAMERA_ANIMATE_CHECKBOX_HEIGHT));		m_ctlAnimateCheckbox.Create(CAMERA_ANIMATE_CHECKBOX_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_AUTOCHECKBOX, rect, this, IDC_CAMERA_ANIMATE_CHECKBOX);	// Report Name caption - This is aligned with the Animate Checkbox above		rect.SetRect(m_cxChar * CAMERA_NAME_CAPTION_X(CenterLine), 				 m_cyChar * CAMERA_NAME_CAPTION_Y, 				 m_cxChar * (CAMERA_NAME_CAPTION_X(CenterLine) + CAMERA_NAME_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_NAME_CAPTION_Y + CAMERA_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(CAMERA_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_CAMERA_NAME_EDIT_FIELD_CAPTION);		// Report Name edit field		rect.SetRect(m_cxChar * CAMERA_NAME_EDIT_FIELD_X(CenterLine), 				 m_cyChar * CAMERA_NAME_EDIT_FIELD_Y, 				 m_cxChar * (CAMERA_NAME_EDIT_FIELD_X(CenterLine) + CAMERA_NAME_EDIT_FIELD_WIDTH), 				 m_cyChar * (CAMERA_NAME_EDIT_FIELD_Y + CAMERA_NAME_EDIT_FIELD_HEIGHT));		m_ctlNameEditField.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT | ES_AUTOHSCROLL,								rect, this, IDC_CAMERA_NAME_EDIT_FIELD);	rect.SetRect(m_cxChar * CAMERA_CANCEL_BUTTON_X(LeftCenterLine), 				 m_cyChar * CAMERA_CANCEL_BUTTON_Y, 				 m_cxChar * (CAMERA_CANCEL_BUTTON_X(LeftCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_CANCEL_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlOkButton.Create(CAMERA_CANCEL_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDCANCEL);	rect.SetRect(m_cxChar * CAMERA_OK_BUTTON_X(RightCenterLine), 				 m_cyChar * CAMERA_OK_BUTTON_Y, 				 m_cxChar * (CAMERA_OK_BUTTON_X(RightCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_OK_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlCancelButton.Create(CAMERA_OK_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_CAMERA_OK);	rect.SetRect(m_cxChar * CAMERA_LICENSE_CAPTION_X(CenterLine), 				 m_cyChar * CAMERA_LICENSE_CAPTION_Y, 				 m_cxChar * (CAMERA_LICENSE_CAPTION_X(CenterLine) + CAMERA_LICENSE_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_LICENSE_CAPTION_Y + CAMERA_LICENSE_CAPTION_HEIGHT));		m_ctlLicenseCaption.Create(CAMERA_LICENSE_CAPTION_LABEL, 				WS_CHILD | WS_VISIBLE | SS_CENTER, rect, this, IDC_CAMERA_LICENSE_CAPTION);	m_ctlLicenseCaption.SetFont(&m_ctlFont);	rect.SetRect(m_cxChar * CAMERA_SESSION_CAPTION_X(CenterLine), 				 m_cyChar * CAMERA_SESSION_CAPTION_Y, 				 m_cxChar * (CAMERA_SESSION_CAPTION_X(CenterLine) + CAMERA_SESSION_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_SESSION_CAPTION_Y + CAMERA_SESSION_CAPTION_HEIGHT));		m_ctlSessionCaption.Create(CAMERA_SESSION_CAPTION_LABEL, 				WS_CHILD | WS_VISIBLE | SS_CENTER, rect, this, IDC_CAMERA_SESSION_CAPTION);	m_ctlSessionCaption.SetFont(&m_ctlFont);	// Set the value of the edit field to the default		m_ctlNameEditField.SetWindowText("");	m_ctlNameEditField.SetLimitText(MAX_FILENAME_CHARS);		// Set the checkbox value to the stored default		m_ctlAnimateCheckbox.SetCheck((DisplayGraphics ? BST_CHECKED : BST_UNCHECKED));	m_ctlUpSelectButton.SetFocus();		// Finally, set the license caption		m_Parent->SetLicenseStatusCaption(&m_ctlLicenseCaption);		// And indicate the current session		CEyeDxVariableList *theVariableList = gGlobalProperties->GetVariableList();	CEyeDxVariable *theVariable = theVariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));	UpdateSessionButtonAndCaption(gGlobalProperties->GetUseSessions(), theVariable, (CButton *)NULL, &m_ctlSessionCaption);				initialized = TRUE;		// Once we are done, send a message to ourselves to start the camera connection	// process. This will guarantee that the window is visible.		PostMessage(EYEDX_MFC_START_CAMERA_MESSAGE, 0, 0);		m_UpDownloaded = false;		m_SideDownloaded = false;							return 0;}	void CMFCRunFromCameraWin::StartCamera(UINT /*wParam*/, LONG /*lParam*/){	CWaitCursor wait;		m_ctlUpProgressCaption.SetWindowText("Connecting to camera...");	// Force a refresh of the window to get the window elements to update properly		// Note that the ConnectToCamera routine will update the DCPortNum value pointed to	// by the m_PortNum parameter.				if (!ConnectToCamera(this, &m_ctlUpProgressCaption, &m_ctlSideProgressCaption, 							&m_ctlUpView, &m_ctlUpCaption, 							&m_ctlSideView, &m_ctlSideCaption,							&m_UpGenericPictInfo, &m_SideGenericPictInfo,							&m_UpPictInfo, &m_SidePictInfo,							m_PortNum, m_ConnectionRate))	{		OnCancelButtonClicked();	}	else	{			m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);		m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);		// We handle three separate cases here, so that the user sees only one notice, rather than		// possibly two successive ones.				// If the quality isn't what we should be using, warn the user		if ((m_UpPictInfo.PictQuality != DC120BestQuality) || (m_SidePictInfo.PictQuality != DC120BestQuality))		{			// One, or the other or both images are not Best quality. Create an appropriate message						if ((m_UpPictInfo.PictQuality != DC120BestQuality) && (m_SidePictInfo.PictQuality != DC120BestQuality))			{				m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				MessageBox("Neither image was taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake both pictures.", AfxGetAppName());			}			else if (m_UpPictInfo.PictQuality != DC120BestQuality)			{				m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);				MessageBox("The Up image was not taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake the picture.", AfxGetAppName());			}			else if (m_SidePictInfo.PictQuality != DC120BestQuality)			{				m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				MessageBox("The Side image was not taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake the picture.", AfxGetAppName());			}		}		else		{			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);			m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);		}				m_ctlUpProgressCaption.SetWindowText(EMPTYSTR);		m_ctlSideProgressCaption.SetWindowText(EMPTYSTR);		m_ctlUpZoomButton.ShowWindow(SW_SHOW);		m_ctlSideZoomButton.ShowWindow(SW_SHOW);				m_UpSelected = TRUE;		m_SideSelected = TRUE;	}}// ---------------------------------------------------------------------------------//		¥ HandleCameraImageSelect// ---------------------------------------------------------------------------------// This routine handles display of the select dialog for camera images.BOOL CMFCRunFromCameraWin::HandleCameraImageSelect(SideSelect theSide,  										   CEyeDxDibStatic *theMainWindowView, 										   CStatic *theMainWindowCaption,										   DCPictInfo *theMainWindowGenericPictInfo,										   DC120PictInfo *theMainWindowPictInfo,										   CStatic *theMainWindowQualityIcon){		// Create the dialog handler.	CMFCCameraImageSelectDlg dlg(this, theSide,								PictNamePtr, 								NumOfPicts,							   	theMainWindowView, 							   	theMainWindowCaption,							   	theMainWindowGenericPictInfo,							   	theMainWindowPictInfo,							   	theMainWindowQualityIcon,							   	&m_hBadBitmap,								&m_hCautionBitmap,								&m_hGoodBitmap);		if (dlg.DoModal() == IDOK)		return TRUE;	return FALSE;	}void CMFCRunFromCameraWin::OnSelectUpButtonClicked(){	if (CMFCRunFromCameraWin::HandleCameraImageSelect(UpImage, &m_ctlUpView, &m_ctlUpCaption, &m_UpGenericPictInfo, &m_UpPictInfo, &m_ctlUpQualityBitmap))	{		if (m_UpDownloaded)		{			// Do not reset the view, because the chooser above just set it to the new image			m_Parent->CleanupUpImage();			m_UpDownloaded = false; // The current image hasn't been fully downloaded yet		}	}}void CMFCRunFromCameraWin::OnSelectSideButtonClicked(){	if (CMFCRunFromCameraWin::HandleCameraImageSelect(SideImage, &m_ctlSideView, &m_ctlSideCaption, &m_SideGenericPictInfo, &m_SidePictInfo, &m_ctlSideQualityBitmap))	{		if (m_SideDownloaded)		{			// Do not reset the view, because the chooser above just set it to the new image			m_Parent->CleanupUpImage();			m_UpDownloaded = false; // The current image hasn't been fully downloaded yet		}	}}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Camera window.// We also set the member that indicates the kind of message to send to // the parent. In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.int CMFCRunFromCameraWin::OnOkButtonClicked(){	// First, we see if there's enough temporary memory to download and run. The peak usage is one 8 bit deep image and 	// three or four 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.	// Since we've already allocated the memory for the images, we don't include them in the counts here.	// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.		short num3ByteDeepImages = 3;	// For the two input images and one pre-scaled annotated image that is written out for the report	short num1ByteDeepImages = 1;	// For the threshold image		CEyeDxLongStringType hintString = (DisplayGraphics ? "Or, press Cancel, turn off animation, and run again." : EMPTYSTR);			CEyeDxMessageType theMemoryMessage = DoCheckForMemory(this, 						DisplayGraphics,						IMAGE_HEIGHT,						IMAGE_WIDTH,						num3ByteDeepImages,						num1ByteDeepImages,						&hintString);	if (theMemoryMessage == kEyeDxDialogOKMessage)	{					// Call the base class to test whether to actually continue				if (CMFCRunWin::OnOkButtonClicked())		{			if (HandlePromptForVariables(this, m_VariableList, m_PromptStyle, CEyeDxVariable::kPromptForSubject) == kEyeDxDialogCancelMessage)			{				OnCancelButtonClicked();			}			else			{				if ((up_image != NULL) && !m_UpDownloaded)				{					free(up_image);					up_image = NULL;					UP_ROWS = UP_COLS = 0;				}								if ((side_image != NULL) && !m_SideDownloaded)				{					free(side_image);					side_image = NULL;					SIDE_ROWS = SIDE_COLS = 0;				}								CWaitCursor wait;								CEyeDxVariable *theUpImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableUPIMAGE));				CEyeDxVariable *theSessionNameVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));						if (!m_UpDownloaded)				{					m_ctlUpProgressBar.ShowWindow(SW_SHOW);					m_ctlUpProgressCaption.ShowWindow(SW_SHOW);														if (!DownloadImageFromCamera(1,&up_image,&UP_ROWS,&UP_COLS,up_filename, theSessionNameVariable, theUpImageVariable,												this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption, SaveFullImages))					{						// Handle this the same as a cancel - close the camera and clean up						OnCancelButtonClicked();						return 0;					}				}								if (!m_SideDownloaded)				{					m_ctlUpProgressBar.ShowWindow(SW_HIDE);										m_ctlSideProgressBar.ShowWindow(SW_SHOW);					m_ctlSideProgressCaption.ShowWindow(SW_SHOW);										CEyeDxVariable *theSideImageVariable = m_VariableList->GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSIDEIMAGE));							if (!DownloadImageFromCamera(2,&side_image,&SIDE_ROWS,&SIDE_COLS,side_filename, theSessionNameVariable, theSideImageVariable,				 									this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption, SaveFullImages))											{						// Handle this the same as a cancel - close the camera and clean up						OnCancelButtonClicked();						return 0;					}				}				// Save the picture information in the appropriate variables				SavePictureInformation(m_VariableList, TRUE, m_UpGenericPictInfo, m_UpPictInfo, TRUE, m_SideGenericPictInfo, m_SidePictInfo);					m_ctlSideProgressBar.ShowWindow(SW_HIDE);									// First, we see if there's enough temporary memory to run. The peak usage is one 8 bit deep image and 				// one or two 3 byte deep images (depending on whether graphics are displayed), plus about 10% overhead.				// We've already allocated the memory for the images, we don't include them in the counts here, since				// we are checking for enough _additional_ memory to run.				// Note that the DoCheckForMemory routine will bump the count if the DisplayGraphics flag is on.								short num3ByteDeepImages = 1;	// For the one pre-scaled annotated image that is written out for the report										short num1ByteDeepImages = 1;	// For the threshold image								CEyeDxLongStringType hintString = (DisplayGraphics ? "Or, press Cancel, turn off animation, and run again." : EMPTYSTR);								CEyeDxMessageType theMessage = DoCheckForMemory(this, 									DisplayGraphics,									IMAGE_HEIGHT,									IMAGE_WIDTH,									num3ByteDeepImages,									num1ByteDeepImages,									&hintString);				if (theMessage == kEyeDxDialogOKMessage)				{															// ALWAYS close the camera!!!										CloseCamera(this);									// Tell ourselves to close, which will send a message to our parent to begin					// analysis					PostMessage(WM_CLOSE, 0, 0);				}				// Otherwise, we stay here to allow the user to turn off animation			}		}	}	return 0;}// This function is called when the Cancel button is pressed. We send a message// to ourselves which will eventually destroy the Run From Camera window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromCameraWin::OnCancelButtonClicked(){	CloseCamera(this);	CMFCRunWin::OnCancelButtonClicked();}void CMFCRunFromCameraWin::OnUpZoomButtonClicked(){	CMFCVerifyZoomDlg rdlg(this, m_Parent, kUpOrientation, m_VariableList, &m_ctlUpView, &m_ctlUpCaption, &m_UpDownloaded);										        rdlg.DoModal();	}		void CMFCRunFromCameraWin::OnSideZoomButtonClicked(){	CMFCVerifyZoomDlg rdlg(this, m_Parent, kSideOrientation, m_VariableList, &m_ctlSideView, &m_ctlSideCaption, &m_SideDownloaded);										        rdlg.DoModal();	}