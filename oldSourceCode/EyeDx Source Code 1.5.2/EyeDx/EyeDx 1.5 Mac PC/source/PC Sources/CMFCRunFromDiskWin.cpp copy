// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "CMFCAnalysisWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "PreviewFileDlg.h"#include "main.h"static LPCTSTR lpszClassName="EyeDxRFD";static LPCTSTR lpszWindowName="EyeDx Photoscreener";extern CMainApp gMainApp;CMFCRunFromDiskWin::CMFCRunFromDiskWin(CRect *posRect, CMainWindow *myParent, BOOL *DirectorySetPtr, char *DefaultImagesDir){	// This creates the Run From Disk window			CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);	// Save the pointer to my parent so I can use it later to set its position				m_parent = myParent;		// Also set the pointer to the parent's flag that indicates the initial images directory	// has been set, and also the name of the initial directory		m_DirectorySetPtr = DirectorySetPtr;		m_DefaultImagesDir = DefaultImagesDir;}BEGIN_MESSAGE_MAP( CMFCRunFromDiskWin, CWnd )ON_BN_CLICKED(IDC_DISK_OK, 	OnDiskOkButtonClicked)ON_BN_CLICKED(IDC_DISK_CANCEL, 	OnDiskCancelButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_UP_BUTTON, 	OnSelectUpButtonClicked)ON_BN_CLICKED(IDC_DISK_SELECT_SIDE_BUTTON, 	OnSelectSideButtonClicked)ON_BN_CLICKED(IDC_DISK_ANIMATE_CHECKBOX, OnDiskAnimateCheckboxClicked)ON_WM_CREATE()ON_WM_CLOSE()END_MESSAGE_MAP()// If the user closes this window - we must tell the parent to close as// well, or else it is left hanging aroundvoid CMFCRunFromDiskWin::OnClose(){	AfxGetMainWnd()->SendMessage(m_MessageToSend, 0, 0);	CWnd::OnClose();}// This function first sends a message to the// main window telling it that the ok button was pressed, and then we delete// ourselvesvoid CMFCRunFromDiskWin::PostNcDestroy(){	delete this;}int CMFCRunFromDiskWin::OnCreate(LPCREATESTRUCT lpcs){	if (CWnd::OnCreate(lpcs) == -1)		return -1;			// Set the sizes and positions of window elements based on the font for the window.	// This will account for larger font sizes that the user may select for the GUI.		CClientDC dc(this);		TEXTMETRIC tm;		dc.GetTextMetrics(&tm);	m_cxChar = tm.tmAveCharWidth;	m_cyChar = tm.tmHeight + tm.tmExternalLeading;		printf("m_cxChar = %d, m_cyChar = %d\n", m_cxChar, m_cyChar);		// Create a font for the static text elements in the window - they will be smaller than	// the normal boldface font.		int nHeight = -tm.tmHeight * 0.75;		m_ctlFont.CreateFont(nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,					CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE, NULL);								m_hBadBitmap.LoadBitmap("ID_BAD_QUALITY_BITMAP");	m_hGoodBitmap.LoadBitmap("ID_GOOD_QUALITY_BITMAP");	m_hCautionBitmap.LoadBitmap("ID_CAUTION_QUALITY_BITMAP");	CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (DISK_VIEW_WIDTH / 2) + DISK_RIGHT_MARGIN;		int RightCenterLine = WindowWidth - DISK_RIGHT_MARGIN - (DISK_VIEW_WIDTH / 2);			// Up Progress caption		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_UP_PROGRESS_CAPTION_X(LeftCenterLine) + DISK_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_CAPTION_Y + DISK_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + DISK_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_CAPTION_Y + DISK_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * DISK_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * DISK_UP_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_UP_PROGRESS_BAR_X(LeftCenterLine) + DISK_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_UP_PROGRESS_BAR_Y + DISK_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * DISK_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (DISK_SIDE_PROGRESS_BAR_X(RightCenterLine) + DISK_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (DISK_SIDE_PROGRESS_BAR_Y + DISK_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_DISK_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * DISK_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * DISK_UP_VIEW_Y, 				 m_cxChar * (DISK_UP_VIEW_X(LeftCenterLine) + DISK_UP_VIEW_WIDTH), 				 m_cyChar * (DISK_UP_VIEW_Y + DISK_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * DISK_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_VIEW_Y, 				 m_cxChar * (DISK_SIDE_VIEW_X(RightCenterLine) + DISK_SIDE_VIEW_WIDTH), 				 m_cyChar * (DISK_SIDE_VIEW_Y + DISK_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_DISK_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * DISK_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * DISK_UP_QUALITY_ICON_Y, 				 m_cxChar * (DISK_UP_QUALITY_ICON_X(LeftCenterLine) + DISK_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_UP_QUALITY_ICON_Y + DISK_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * DISK_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (DISK_SIDE_QUALITY_ICON_X(RightCenterLine) + DISK_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (DISK_SIDE_QUALITY_ICON_Y + DISK_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_DISK_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Up Image caption		rect.SetRect(m_cxChar * DISK_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * DISK_UP_CAPTION_Y, 				 m_cxChar * (DISK_UP_CAPTION_X(LeftCenterLine) + DISK_UP_CAPTION_WIDTH), 				 m_cyChar * (DISK_UP_CAPTION_Y + DISK_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * DISK_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * DISK_SIDE_CAPTION_Y, 				 m_cxChar * (DISK_SIDE_CAPTION_X(RightCenterLine) + DISK_SIDE_CAPTION_WIDTH), 				 m_cyChar * (DISK_SIDE_CAPTION_Y + DISK_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_DISK_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// Select Up Image button			rect.SetRect(m_cxChar * DISK_SELECT_UP_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_SELECT_UP_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_UP_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_UP_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlUpSelectButton.Create(DISK_SELECT_UP_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, rect, this, IDC_DISK_SELECT_UP_BUTTON);	// Select Side Image button		rect.SetRect(m_cxChar * DISK_SELECT_SIDE_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_SELECT_SIDE_BUTTON_Y, 				 m_cxChar * (DISK_SELECT_SIDE_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_SELECT_SIDE_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlSideSelectButton.Create(DISK_SELECT_SIDE_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, rect, this, IDC_DISK_SELECT_SIDE_BUTTON);	// Show Animation during processing checkbox		rect.SetRect(m_cxChar * DISK_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * DISK_ANIMATE_CHECKBOX_Y, 				 m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_ANIMATE_CHECKBOX_WIDTH), 				 m_cyChar * (DISK_ANIMATE_CHECKBOX_Y + DISK_ANIMATE_CHECKBOX_HEIGHT));		m_ctlAnimateCheckbox.Create(DISK_ANIMATE_CHECKBOX_LABEL, 								WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX, rect, this, IDC_DISK_ANIMATE_CHECKBOX);	// Report Name caption - This is aligned with the Animate Checkbox above		rect.SetRect(m_cxChar * DISK_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * DISK_NAME_CAPTION_Y, 				 m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH), 				 m_cyChar * (DISK_NAME_CAPTION_Y + DISK_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(DISK_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_DISK_NAME_EDIT_FIELD_CAPTION);		// Report Name edit field		rect.SetRect(m_cxChar * (DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH + 1), 				 m_cyChar * DISK_NAME_EDIT_FIELD_Y, 				 m_cxChar * ((DISK_ANIMATE_CHECKBOX_X(CenterLine) + DISK_NAME_CAPTION_WIDTH + 1) + DISK_NAME_EDIT_FIELD_WIDTH), 				 m_cyChar * (DISK_NAME_EDIT_FIELD_Y + DISK_NAME_EDIT_FIELD_HEIGHT));		m_ctlNameEditField.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | ES_LEFT,								rect, this, IDC_DISK_NAME_EDIT_FIELD);	rect.SetRect(m_cxChar * DISK_CANCEL_BUTTON_X(LeftCenterLine), 				 m_cyChar * DISK_CANCEL_BUTTON_Y, 				 m_cxChar * (DISK_CANCEL_BUTTON_X(LeftCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_CANCEL_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlOkButton.Create(DISK_CANCEL_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, rect, this, IDC_DISK_CANCEL);	rect.SetRect(m_cxChar * DISK_OK_BUTTON_X(RightCenterLine), 				 m_cyChar * DISK_OK_BUTTON_Y, 				 m_cxChar * (DISK_OK_BUTTON_X(RightCenterLine) + DISK_BUTTON_WIDTH), 				 m_cyChar * (DISK_OK_BUTTON_Y + DISK_BUTTON_HEIGHT));		m_ctlCancelButton.Create(DISK_OK_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON, rect, this, IDC_DISK_OK);	// Default to sending the WM_CLOSE message to my parent. We change this only when the	// Cancel or OK buttons are pressed.		m_MessageToSend = WM_CLOSE;		// Set up some of our variables		up_image = NULL;	side_image = NULL;		m_UpSelected = FALSE;	m_SideSelected = FALSE;		// Set the value of the edit field to the default		m_ctlNameEditField.SetWindowText("No name");	m_ctlNameEditField.SetLimitText(MAX_FILENAME_CHARS);		// Set the checkbox value to the stored default		m_ctlAnimateCheckbox.SetCheck((DisplayGraphics ? BST_CHECKED : BST_UNCHECKED));		RunInProgress = 2;	return 0;}char szFilters[] = "KDC files (*.kdc)";void CMFCRunFromDiskWin::OnSelectUpButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Up Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		m_UpSelected = true;		// If a file is already displayed, delete the old one		if (up_image != NULL)		{		    free(up_image);		    up_image = NULL;		    UP_ROWS = UP_COLS = 0;		}		strcpy(up_filename, dlg.GetFileName());				FILE *fileptr = fopen(dlg.GetPathName(), "rb");				if (!fileptr)			MessageBox("Cannot open file.", "Error", MB_OK);		else						{			m_ctlUpProgressBar.ShowWindow(SW_SHOW);			m_ctlUpProgressCaption.ShowWindow(SW_SHOW);			if (ReadImageFromFile(fileptr, &up_image ,&UP_ROWS,&UP_COLS, up_filename, &m_UpPictInfo, 									this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption, &m_ctlUpCaption) == 0)				strcpy(up_filename,"");			else			{				m_ctlUpProgressBar.ShowWindow(SW_HIDE);				m_ctlUpProgressCaption.ShowWindow(SW_HIDE);				m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);								// If the quality isn't what we should be using, warn the user				if (m_UpPictInfo.PictQuality != DC120BestQuality)				{				 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"				 				"and analysis of this image may produce incorrect results.\n"				 				"EyeDx recommends you retake this picture.", "Warning", MB_OK);					m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				}				else					m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlUpView.SetImageFromRaw24Bit(up_image, UP_ROWS, UP_COLS);			}		}	}}void CMFCRunFromDiskWin::OnSelectSideButtonClicked(){	CPreviewFileDlg dlg(TRUE, "kdc", "*.kdc", OFN_FILEMUSTEXIST | OFN_HIDEREADONLY, szFilters, this);		static char szTitle[] = "EyeDx: Select Side Image";	dlg.m_ofn.lpstrTitle = szTitle;		// If we have not set the default images directory, do it only the first time we present	// the open file dialog. We update the parent's flag indicating that we have done this,	// and this flag is passed to us on subsequent calls.		if (*m_DirectorySetPtr == FALSE)	{		*m_DirectorySetPtr = TRUE;		dlg.m_ofn.lpstrInitialDir = m_DefaultImagesDir;	}		if (dlg.DoModal() == IDOK)	{		m_SideSelected = true;		// If a file is already displayed, delete the old one		if (side_image != NULL)		{		    free(side_image);		    side_image = NULL;		    SIDE_ROWS = SIDE_COLS = 0;		}		strcpy(side_filename, dlg.GetFileName());				FILE *fileptr = fopen(dlg.GetPathName(), "rb");				if (!fileptr)			MessageBox("Cannot open file.", "Error", MB_OK);		else						{			m_ctlSideProgressBar.ShowWindow(SW_SHOW);			m_ctlSideProgressCaption.ShowWindow(SW_SHOW);			if (ReadImageFromFile(fileptr, &side_image,&SIDE_ROWS,&SIDE_COLS, side_filename, &m_SidePictInfo, 									this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption, &m_ctlSideCaption) == 0)				strcpy(side_filename,"");			else			{				m_ctlSideProgressBar.ShowWindow(SW_HIDE);				m_ctlSideProgressCaption.ShowWindow(SW_HIDE);				m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);								// If the quality isn't what we should be using, warn the user				if (m_SidePictInfo.PictQuality != DC120BestQuality)				{				 	MessageBox("This image was not taken with the recommended 'Best' image quality setting\n"				 				"and analysis of this image may produce incorrect results.\n"				 				"EyeDx recommends you retake this picture.", "Warning", MB_OK);					m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				}				else					m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlSideView.SetImageFromRaw24Bit(side_image, SIDE_ROWS, SIDE_COLS);			}		}	}}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromDiskWin::OnDiskOkButtonClicked(){	CRect popUpRect;		if (m_UpSelected && m_SideSelected)	{		CString theReportNameString;				m_ctlNameEditField.GetWindowText(theReportNameString);				if (m_parent->CheckReportValidity(theReportNameString))		{			GetClientRect(&popUpRect);			m_parent->SetParentPosition(&popUpRect);						// We don't Show the Main window here, as it will be transitioning to 			// the Analysis window				m_MessageToSend = EYEDX_MFC_OK_MESSAGE;			PostMessage(WM_CLOSE, 0, 0);		}	}	else	{		MessageBox("You must choose both images.", "Error", MB_OK);	}}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Disk window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromDiskWin::OnDiskCancelButtonClicked(){	CRect popUpRect;		// Set the Main Window's postion, and then show it. That will make it	// visible before we disappear, so that the transition between windows	// is less abrupt.		GetClientRect(&popUpRect);	m_parent->SetParentPosition(&popUpRect);	m_parent->ShowWindow(SW_SHOW);		m_MessageToSend = EYEDX_MFC_CANCEL_MESSAGE;	PostMessage(WM_CLOSE, 0, 0);}void CMFCRunFromDiskWin::OnDiskAnimateCheckboxClicked(){	DisplayGraphics = (m_ctlAnimateCheckbox.GetCheck() ? 1 : 0);}