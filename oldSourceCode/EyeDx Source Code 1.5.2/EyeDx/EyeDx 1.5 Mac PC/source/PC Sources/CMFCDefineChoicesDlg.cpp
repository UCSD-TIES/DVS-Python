// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "globals.h"#include "main.h"#if defined (WIN32)	#define IS_WIN32	TRUE#else	#define IS_WIN32	FALSE#endifBEGIN_MESSAGE_MAP( CMFCDefineChoicesDlg, CDialog )ON_BN_CLICKED(IDC_DEFINECHOICES_MODIFYBUTTON, OnModifyPressed)ON_BN_CLICKED(IDC_DEFINECHOICES_MOVEUPBUTTON, OnMoveUpPressed)ON_BN_CLICKED(IDC_DEFINECHOICES_MOVEDOWNBUTTON, OnMoveDownPressed)ON_BN_CLICKED(IDC_DEFINECHOICES_NEWBUTTON, OnNewPressed)ON_BN_CLICKED(IDC_DEFINECHOICES_REMOVEBUTTON, OnRemovePressed)ON_LBN_SELCHANGE(IDC_DEFINECHOICES_CHOICELIST, OnChoiceListClicked)END_MESSAGE_MAP()CMFCDefineChoicesDlg::CMFCDefineChoicesDlg(CWnd *pParentWnd, CEyeDxVariable *theVariable, CEyeDxBooleanType allowEditing) :		CDialog(IDD_DEFINECHOICES_DIALOG, pParentWnd) {	m_Variable = theVariable;		m_AllowEditing = allowEditing;}CEyeDxBooleanType CMFCDefineChoicesDlg::OnToolTipText(UINT, NMHDR* pNMHDR, LRESULT*){	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pNMHDR;	if (!(pTTT->uFlags & TTF_IDISHWND))	// the ID must be a handle to a window		return FALSE;			UINT uID = pNMHDR->idFrom;	uID = ::GetDlgCtrlID((HWND)uID);			CString strTipText;		// Attempt to load a ToolTip string that corresponds to the control's ID		if(!strTipText.LoadString(uID))		return FALSE;		// Stuff text into the ToolTip, 80 characters maximum		strncpy(pTTT->lpszText, strTipText, 80);	return TRUE;}const long kChoiceStringWidth = 182;void CMFCDefineChoicesDlg::OnCancel(){	// We need to delete our copied strings - the destructor will take care of the list itself		int numItems = m_WorkingOptionStringList->GetSize();		for (int theItem = 0; theItem < numItems; theItem++)	{		CEyeDxShortStringType *theString = m_WorkingOptionStringList->GetAt(theItem);		delete theString;	}	delete m_WorkingOptionStringList;		CDialog::OnCancel();}void CMFCDefineChoicesDlg::OnOK(){	long theItem;		if (m_AllowEditing)	{		// We can't get here unless the user has actually defined at least one choice. The OK		// button is disabled, otherwise.				// All we have to do here is set the variable's list				// First, delete the items in the existing list				int numItems = m_OptionStringList->GetSize();				for (int theItem = 0; theItem < numItems; theItem++)		{			CEyeDxShortStringType *theString = m_OptionStringList->GetAt(theItem);			delete theString;		}				m_OptionStringList->RemoveAll();				// Copy the array - this will delete the items in the m_OptionStringList first.				numItems = m_WorkingOptionStringList->GetSize();				for (int theItem = 0; theItem < numItems; theItem++)		{			CEyeDxShortStringType *theString = m_WorkingOptionStringList->GetAt(theItem);			m_OptionStringList->Add(theString);		}				m_WorkingOptionStringList->RemoveAll();				delete m_WorkingOptionStringList;	}	CDialog::OnOK();}		void CMFCDefineChoicesDlg::OnChoiceListClicked(){	CEyeDxShortStringType *theString;			// Look up the item that they clicked on		int theItem = m_ChoiceTable->GetCurSel();		if (m_AllowEditing)	{			if (theItem != CB_ERR)		{				int numItems = m_ChoiceTable->GetCount();							m_MoveUpButton->EnableWindow(FALSE);			m_MoveDownButton->EnableWindow(FALSE);			m_RemoveItemButton->EnableWindow(FALSE);						// If they haven't clicked on the first item, then enable the Move Up Button						if (theItem > 0)				{									m_MoveUpButton->EnableWindow(TRUE);				m_RemoveItemButton->EnableWindow(TRUE);			}							// And if they haven't clicked on the last item, enable the Move Down Button						if (theItem < (numItems - 1))			{				m_MoveDownButton->EnableWindow(TRUE);				m_RemoveItemButton->EnableWindow(TRUE);			}							// Now get the text of the item and put it in the edit field													theString = m_WorkingOptionStringList->GetAt(theItem);						// Set the text of the edit field						m_ItemStringEditField->SetWindowText(*theString);		}	}	else	{		// Nothing is selected, or they can't edit it anyway, so disable buttons and the edit field			m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);		m_ModifyItemButton->EnableWindow(FALSE);		m_RemoveItemButton->EnableWindow(FALSE);						m_ItemStringEditField->SetWindowText("");		}}void CMFCDefineChoicesDlg::OnMoveUpPressed(){			// Get the item selected, and move it up in the list	int theItem = m_ChoiceTable->GetCurSel();		if (theItem != CB_ERR)	{			// All we do is swap the entries in the list, making sure that the list is not resorted.				CEyeDxShortStringType *theFirstString = m_WorkingOptionStringList->GetAt(theItem);		CEyeDxShortStringType *theSecondString = m_WorkingOptionStringList->GetAt(theItem - 1);				m_WorkingOptionStringList->SetAt(theItem - 1, theFirstString);		m_WorkingOptionStringList->SetAt(theItem, theSecondString);				// Update the list						UpdateChoicesList(theItem - 1);	}}		void CMFCDefineChoicesDlg::OnMoveDownPressed(){					// Get the item selected, and move it down in the list. 		int theItem = m_ChoiceTable->GetCurSel();		if (theItem != CB_ERR)	{			// All we do is swap the entries in the list, making sure that the list is not resorted.				CEyeDxShortStringType *theFirstString = m_WorkingOptionStringList->GetAt(theItem);		CEyeDxShortStringType *theSecondString = m_WorkingOptionStringList->GetAt(theItem + 1);				m_WorkingOptionStringList->SetAt(theItem + 1, theFirstString);		m_WorkingOptionStringList->SetAt(theItem, theSecondString);							// Update the list and also tell the routine to NOT update the menu, since we didn't change the number of		// items in the list				UpdateChoicesList(theItem + 1);	}}		void CMFCDefineChoicesDlg::OnNewPressed(){					CEyeDxShortStringType *theString;	CEyeDxShortStringType theValueString;				// We get the value they typed in and validate it. It must be non-empty, and must not be the	// same as another choice string.		m_ItemStringEditField->GetWindowText(theValueString);		short theStrLength = theValueString.GetLength();		if (theStrLength == 0)	{		MessageBox("You must enter a string that represents the choice's value!", AfxGetAppName());	}	else	{				// Check to see if the entry is all spaces. That's also a no-no								short i = 1;		while (i <= theStrLength)		{			if (theValueString[i] != ' ')				break;			i++;		}				// If we got to the end of the string and found all spaces, or if the		// string length is zero, then they didn't enter a value. That may or may not		// be a problem - we check that next.				if (i > theStrLength)		{			MessageBox("You must enter a string that represents the choice's value!", AfxGetAppName());		}		else		{				CEyeDxBooleanType found = false;						// Check to see if this string is already defined			int numItems = m_WorkingOptionStringList->GetSize();						int theItem = 0; 			while (theItem < numItems && !found)			{				CEyeDxShortStringType *theExistingString = m_WorkingOptionStringList->GetAt(theItem);							if (*theExistingString == theValueString)					found = true;				theItem++;			}						if (found)			{				MessageBox("Sorry, that choice value is already defined!", AfxGetAppName());			}			else			{							// We will insert after the current row. If the last item is selected, we will end up				// appending to the list								theItem = m_ChoiceTable->GetCurSel() + 1;								// Make a copy of the string and insert it into the list								CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(theValueString);					m_WorkingOptionStringList->InsertAt(theItem, theStringCopy, 1);					UpdateChoicesList(theItem);			}		}	}}		void CMFCDefineChoicesDlg::OnModifyPressed(){					CEyeDxShortStringType *theString;	CEyeDxShortStringType theValueString;				// We get the value they typed in and validate it. It must be non-empty, and must not be the	// same as another choice string.		m_ItemStringEditField->GetWindowText(theValueString);		short theStrLength = theValueString.GetLength();		if (theStrLength == 0)	{		MessageBox("You must enter a string that represents the choice's value!", AfxGetAppName());	}	else	{				// Check to see if the entry is all spaces. That's also a no-no								short i = 1;		while (i <= theStrLength)		{			if (theValueString[i] != ' ')				break;			i++;		}				// If we got to the end of the string and found all spaces, or if the		// string length is zero, then they didn't enter a value. That may or may not		// be a problem - we check that next.				if (i > theStrLength)		{			MessageBox("You must enter a string that represents the choice's value!", AfxGetAppName());		}		else		{				CEyeDxBooleanType found = false;						// Check to see if this string is already defined			int numItems = m_WorkingOptionStringList->GetSize();						int theItem = 0; 			while (theItem < numItems && !found)			{				CEyeDxShortStringType *theExistingString = m_WorkingOptionStringList->GetAt(theItem);							if (*theExistingString == theValueString)					found = true;				theItem++;			}						if (found)			{				MessageBox("Sorry, that choice value is already defined!", AfxGetAppName());			}			else			{				theItem = m_ChoiceTable->GetCurSel();								// We need to update the existing string for this item. Retrieve a pointer to it				// and copy in the edit field's value								CEyeDxShortStringType *theOldChoiceStr = m_WorkingOptionStringList->GetAt(theItem);								*theOldChoiceStr = theValueString;								// Since the list is just pointing at the string, we're finished.				UpdateChoicesList(theItem);			}		}	}}		void CMFCDefineChoicesDlg::OnRemovePressed(){					int theItem = m_ChoiceTable->GetCurSel();		if (theItem != CB_ERR)	{			// Remove the corresponding item from the working list. That means fetching the string and deleting it		// first, and then deleting the item in the list				CEyeDxShortStringType *theOldChoiceStr = m_WorkingOptionStringList->GetAt(theItem);				delete theOldChoiceStr;								m_WorkingOptionStringList->RemoveAt(theItem);				// Update the list and also tell the routine to update the menu. We tell the routine to select		// the previous item in the list, if there is one.				// Update the list and also tell the routine to update the menu. We tell the routine to select		// the previous item in the list, if there is one.				if (m_WorkingOptionStringList->GetSize() > 0)		{			// We have a special case here - if the first item was deleted, we want to just select the first			// item in the list.						theItem--;			if (theItem == 0)				theItem = 1;		}		else			theItem = 0;					// Note that if the last item was deleted, theItem will be zero, and the UpdateChoicesList		// routine will handle updating buttons correctly.					UpdateChoicesList(theItem);	}}// ---------------------------------------------------------------------------------//		¥ SetupDialog// ---------------------------------------------------------------------------------intCMFCDefineChoicesDlg::OnInitDialog(){	m_ChoiceTable = (CListBox *) GetDlgItem((IDC_DEFINECHOICES_CHOICELIST));			m_MoveUpButton = (CButton *) GetDlgItem((IDC_DEFINECHOICES_MOVEUPBUTTON));		m_MoveDownButton = (CButton *) GetDlgItem((IDC_DEFINECHOICES_MOVEDOWNBUTTON));		m_RemoveItemButton = (CButton *) GetDlgItem((IDC_DEFINECHOICES_REMOVEBUTTON));		m_NewItemButton = (CButton *) GetDlgItem((IDC_DEFINECHOICES_NEWBUTTON));		m_ModifyItemButton = (CButton *) GetDlgItem((IDC_DEFINECHOICES_MODIFYBUTTON));		m_ItemStringEditField = (CEdit *) GetDlgItem((IDC_DEFINECHOICES_VALUEFIELD));		m_CancelButton = (CButton *) GetDlgItem((IDCANCEL));		m_SaveButton = (CButton *) GetDlgItem((IDOK));		// Get the current list of options and put them in the list		m_OptionStringList = m_Variable->GetOptionStringsArray();				// Make a copy of it and the associated strings. We need to do this so we don't change the original	// list while the user makes changes. That allows for the Cancel operation to leave the original list	// alone.		m_WorkingOptionStringList = new CTemplateShortStrArray();	int numChoices = m_OptionStringList->GetSize();		for (int theItem = 0; theItem < numChoices; theItem++)	{		CEyeDxShortStringType *theString = m_OptionStringList->GetAt(theItem);			CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(*theString);					m_WorkingOptionStringList->Add(theStringCopy);	}		// Update the list and also tell the routine to select the first item if there are any items in the list		if (m_WorkingOptionStringList->GetSize() == 0)		UpdateChoicesList(-1);	else		UpdateChoicesList(0);	// In the case where we don't allow editing, we change the save button so that the user doesn't think they	// are saving anything.		if (!m_AllowEditing)	{		m_CancelButton->EnableWindow(FALSE);	// For consistency - we disable the Cancel and set the Save to say "OK"		m_SaveButton->SetWindowText("OK");			m_NewItemButton->EnableWindow(FALSE);	}		return TRUE;} voidCMFCDefineChoicesDlg::UpdateChoicesList(long itemToSelect){	// Here we have to parse the variable list and add all of the prompted variables in the order in which they are	// supposed to be prompted.	m_ChoiceTable->ResetContent();		// Figure out how many choices there are	int theNumberOfChoices = m_WorkingOptionStringList->GetSize();			for (int theItem = 0; theItem < theNumberOfChoices; theItem++)	{		CEyeDxShortStringType *theString = m_WorkingOptionStringList->GetAt(theItem);			m_ChoiceTable->AddString(*theString);	}				if (theNumberOfChoices == 0)		m_RemoveItemButton->EnableWindow(FALSE);		if (m_AllowEditing && (itemToSelect >= 0))	{		m_ChoiceTable->SetCurSel(itemToSelect);	// Make sure it's visible		// Now update the Move Up and Down buttons				m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);				// If the the selected item isn't the first item, then enable the Move Up Button				if (itemToSelect > 0)									m_MoveUpButton->EnableWindow(TRUE);					// And if the selected item isn't the last item, enable the Move Down Button				if (itemToSelect < theNumberOfChoices - 1)			m_MoveDownButton->EnableWindow(TRUE);					m_RemoveItemButton->EnableWindow(TRUE);		// Now, fetch the string associated with the chosen item and put it in the		// edit field				CEyeDxShortStringType *theString = m_WorkingOptionStringList->GetAt(itemToSelect);				m_ItemStringEditField->SetWindowText(*theString);								}	else	{		m_MoveUpButton->EnableWindow(FALSE);		m_MoveDownButton->EnableWindow(FALSE);			}		// If there are items in the list, we allow the user to modify and remove items. Otherwise,	// All they can do is add items.		if (m_AllowEditing && (theNumberOfChoices > 0))	{		m_ModifyItemButton->EnableWindow(TRUE);		m_RemoveItemButton->EnableWindow(TRUE);		m_SaveButton->EnableWindow(TRUE);		m_ItemStringEditField->EnableWindow(TRUE);	}	else	{		m_ModifyItemButton->EnableWindow(FALSE);		m_RemoveItemButton->EnableWindow(FALSE);				// If not editing, we leave the OK button enabled, but we disable the New button and the edit field		if (!m_AllowEditing)		{			m_SaveButton->EnableWindow(TRUE);			m_NewItemButton->EnableWindow(FALSE);			m_ItemStringEditField->EnableWindow(FALSE);		}				}}