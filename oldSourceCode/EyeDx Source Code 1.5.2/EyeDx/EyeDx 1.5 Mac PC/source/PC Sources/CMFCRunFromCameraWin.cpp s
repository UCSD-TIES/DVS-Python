// main.cp#include <stdio.h>#include <windows.h>#include <wingdi.h>#include <winbase.h>#include <winuser.h>#include <process.h>#include "resource.h"#include "CEyeDxDib.h"#include "CEyeDxDibStatic.h"#include "globals.h"#include "CMFCCameraImageSelectDlg.h"#include "CMFCAnalysisWin.h"#include "CMFCRunWin.h"#include "CMFCRunFromCameraWin.h"#include "CMFCRunFromDiskWin.h"#include "CMFCAboutDialog.h"#include "EyeDxMFCMessages.h"#include "PreviewFileDlg.h"#include "main.h"static LPCTSTR lpszWindowName="EyeDx Photoscreener";extern CMainApp gMainApp;CMFCRunFromCameraWin::CMFCRunFromCameraWin(CRect *posRect, CMainWindow *myParent, 						BOOL *DirectorySetPtr, char *DefaultImagesDir)						: CMFCRunWin(posRect, myParent, DirectorySetPtr, DefaultImagesDir){	// This creates the Run From Camera window			CString strWndClass = AfxRegisterWndClass(		CS_DBLCLKS,		gMainApp.LoadStandardCursor(IDC_ARROW),		(HBRUSH) (COLOR_3DFACE + 1),		gMainApp.LoadIcon("ID_EYEDX_ICON_SM"));			CreateEx(0, strWndClass, lpszWindowName, 		WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX,		posRect->left, posRect->top, posRect->Width(), posRect->Height(), 		NULL, NULL);}BEGIN_MESSAGE_MAP( CMFCRunFromCameraWin, CMFCRunWin )ON_MESSAGE(EYEDX_MFC_START_CAMERA_MESSAGE, StartCamera)ON_BN_CLICKED(IDC_CAMERA_OK, 	OnOkButtonClicked)ON_BN_CLICKED(IDC_CAMERA_CANCEL, 	OnCancelButtonClicked)ON_BN_CLICKED(IDC_CAMERA_SELECT_UP_BUTTON, 	OnSelectUpButtonClicked)ON_BN_CLICKED(IDC_CAMERA_SELECT_SIDE_BUTTON, 	OnSelectSideButtonClicked)ON_BN_CLICKED(IDC_CAMERA_ANIMATE_CHECKBOX, OnAnimateCheckboxClicked)ON_WM_CREATE()END_MESSAGE_MAP()BOOL CMFCRunFromCameraWin::PreTranslateMessage(MSG *pMsg){	if (IsDialogMessage(pMsg) == TRUE)		return TRUE;	else if (CWnd::PreTranslateMessage(pMsg) == TRUE)		return TRUE;	else 		return FALSE;}int CMFCRunFromCameraWin::OnCreate(LPCREATESTRUCT lpcs){	if (CMFCRunWin::OnCreate(lpcs) == -1)		return -1;			RunInProgress = 1;			CRect rect;		GetClientRect(&rect);		int WindowWidth = (rect.right-rect.left) / m_cxChar;		int CenterLine = WindowWidth / 2;		int LeftCenterLine = (CAMERA_VIEW_WIDTH / 2) + CAMERA_RIGHT_MARGIN;		int RightCenterLine = WindowWidth - CAMERA_RIGHT_MARGIN - (CAMERA_VIEW_WIDTH / 2);			// Up Progress caption		rect.SetRect(m_cxChar * CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_PROGRESS_CAPTION_Y, 				 m_cxChar * (CAMERA_UP_PROGRESS_CAPTION_X(LeftCenterLine) + CAMERA_UP_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_UP_PROGRESS_CAPTION_Y + CAMERA_UP_PROGRESS_CAPTION_HEIGHT));		m_ctlUpProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_UP_PROGRESS_CAPTION);	m_ctlUpProgressCaption.SetFont(&m_ctlFont);		// Side Progress caption		rect.SetRect(m_cxChar * CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_PROGRESS_CAPTION_Y, 				 m_cxChar * (CAMERA_SIDE_PROGRESS_CAPTION_X(RightCenterLine) + CAMERA_SIDE_PROGRESS_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_SIDE_PROGRESS_CAPTION_Y + CAMERA_SIDE_PROGRESS_CAPTION_HEIGHT));		m_ctlSideProgressCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_SIDE_PROGRESS_CAPTION);	m_ctlSideProgressCaption.SetFont(&m_ctlFont);	// Up Progress bar		rect.SetRect(m_cxChar * CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_PROGRESS_BAR_Y, 				 m_cxChar * (CAMERA_UP_PROGRESS_BAR_X(LeftCenterLine) + CAMERA_UP_PROGRESS_BAR_WIDTH), 				 m_cyChar * (CAMERA_UP_PROGRESS_BAR_Y + CAMERA_UP_PROGRESS_BAR_HEIGHT));	m_ctlUpProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_CAMERA_UP_PROGRESS_BAR);	// Side Progress bar		rect.SetRect(m_cxChar * CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_PROGRESS_BAR_Y, 				 m_cxChar * (CAMERA_SIDE_PROGRESS_BAR_X(RightCenterLine) + CAMERA_SIDE_PROGRESS_BAR_WIDTH), 				 m_cyChar * (CAMERA_SIDE_PROGRESS_BAR_Y + CAMERA_SIDE_PROGRESS_BAR_HEIGHT));	m_ctlSideProgressBar.Create(WS_CHILD | WS_BORDER, rect, this, IDC_CAMERA_SIDE_PROGRESS_BAR);	// Up Image View		rect.SetRect(m_cxChar * CAMERA_UP_VIEW_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_VIEW_Y, 				 m_cxChar * (CAMERA_UP_VIEW_X(LeftCenterLine) + CAMERA_UP_VIEW_WIDTH), 				 m_cyChar * (CAMERA_UP_VIEW_Y + CAMERA_UP_VIEW_HEIGHT));		m_ctlUpView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_CAMERA_UP_VIEW);		// Side Image View		rect.SetRect(m_cxChar * CAMERA_SIDE_VIEW_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_VIEW_Y, 				 m_cxChar * (CAMERA_SIDE_VIEW_X(RightCenterLine) + CAMERA_SIDE_VIEW_WIDTH), 				 m_cyChar * (CAMERA_SIDE_VIEW_Y + CAMERA_SIDE_VIEW_HEIGHT));		m_ctlSideView.Create("", WS_CHILD | WS_VISIBLE | SS_BITMAP | SS_SUNKEN, rect, this, IDC_CAMERA_SIDE_VIEW);	// Up Image Quality Bitmap		rect.SetRect(m_cxChar * CAMERA_UP_QUALITY_ICON_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_QUALITY_ICON_Y, 				 m_cxChar * (CAMERA_UP_QUALITY_ICON_X(LeftCenterLine) + CAMERA_UP_QUALITY_ICON_WIDTH), 				 m_cyChar * (CAMERA_UP_QUALITY_ICON_Y + CAMERA_UP_QUALITY_ICON_HEIGHT));		m_ctlUpQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_CAMERA_UP_QUALITY_ICON);			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);	// Side Image Quality Bitmap	rect.SetRect(m_cxChar * CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_QUALITY_ICON_Y, 				 m_cxChar * (CAMERA_SIDE_QUALITY_ICON_X(RightCenterLine) + CAMERA_SIDE_QUALITY_ICON_WIDTH), 				 m_cyChar * (CAMERA_SIDE_QUALITY_ICON_Y + CAMERA_SIDE_QUALITY_ICON_HEIGHT));		m_ctlSideQualityBitmap.Create("", WS_CHILD | SS_BITMAP, rect, this, IDC_CAMERA_SIDE_QUALITY_ICON);	m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);	// Up Image caption		rect.SetRect(m_cxChar * CAMERA_UP_CAPTION_X(LeftCenterLine), 				 m_cyChar * CAMERA_UP_CAPTION_Y, 				 m_cxChar * (CAMERA_UP_CAPTION_X(LeftCenterLine) + CAMERA_UP_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_UP_CAPTION_Y + CAMERA_UP_CAPTION_HEIGHT));		m_ctlUpCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_UP_CAPTION);	m_ctlUpCaption.SetFont(&m_ctlFont);		// Side Image caption		rect.SetRect(m_cxChar * CAMERA_SIDE_CAPTION_X(RightCenterLine), 				 m_cyChar * CAMERA_SIDE_CAPTION_Y, 				 m_cxChar * (CAMERA_SIDE_CAPTION_X(RightCenterLine) + CAMERA_SIDE_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_SIDE_CAPTION_Y + CAMERA_SIDE_CAPTION_HEIGHT));		m_ctlSideCaption.Create("", WS_CHILD | WS_VISIBLE | SS_LEFT, rect, this, IDC_CAMERA_SIDE_CAPTION);	m_ctlSideCaption.SetFont(&m_ctlFont);		// Select Up Image button			rect.SetRect(m_cxChar * CAMERA_SELECT_UP_BUTTON_X(LeftCenterLine), 				 m_cyChar * CAMERA_SELECT_UP_BUTTON_Y, 				 m_cxChar * (CAMERA_SELECT_UP_BUTTON_X(LeftCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_SELECT_UP_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlUpSelectButton.Create(CAMERA_SELECT_UP_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_CAMERA_SELECT_UP_BUTTON);	// Select Side Image button		rect.SetRect(m_cxChar * CAMERA_SELECT_SIDE_BUTTON_X(RightCenterLine), 				 m_cyChar * CAMERA_SELECT_SIDE_BUTTON_Y, 				 m_cxChar * (CAMERA_SELECT_SIDE_BUTTON_X(RightCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_SELECT_SIDE_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlSideSelectButton.Create(CAMERA_SELECT_SIDE_BUTTON_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_CAMERA_SELECT_SIDE_BUTTON);	// Show Animation during processing checkbox		rect.SetRect(m_cxChar * CAMERA_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * CAMERA_ANIMATE_CHECKBOX_Y, 				 m_cxChar * (CAMERA_ANIMATE_CHECKBOX_X(CenterLine) + CAMERA_ANIMATE_CHECKBOX_WIDTH), 				 m_cyChar * (CAMERA_ANIMATE_CHECKBOX_Y + CAMERA_ANIMATE_CHECKBOX_HEIGHT));		m_ctlAnimateCheckbox.Create(CAMERA_ANIMATE_CHECKBOX_LABEL, 								WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_AUTOCHECKBOX, rect, this, IDC_CAMERA_ANIMATE_CHECKBOX);	// Report Name caption - This is aligned with the Animate Checkbox above		rect.SetRect(m_cxChar * CAMERA_ANIMATE_CHECKBOX_X(CenterLine), 				 m_cyChar * CAMERA_NAME_CAPTION_Y, 				 m_cxChar * (CAMERA_ANIMATE_CHECKBOX_X(CenterLine) + CAMERA_NAME_CAPTION_WIDTH), 				 m_cyChar * (CAMERA_NAME_CAPTION_Y + CAMERA_NAME_CAPTION_HEIGHT));		m_ctlNameCaption.Create(CAMERA_NAME_CAPTION_LABEL, 								WS_CHILD | WS_VISIBLE | SS_RIGHT, rect, this, IDC_CAMERA_NAME_EDIT_FIELD_CAPTION);		// Report Name edit field		rect.SetRect(m_cxChar * (CAMERA_ANIMATE_CHECKBOX_X(CenterLine) + CAMERA_NAME_CAPTION_WIDTH + 1), 				 m_cyChar * CAMERA_NAME_EDIT_FIELD_Y, 				 m_cxChar * ((CAMERA_ANIMATE_CHECKBOX_X(CenterLine) + CAMERA_NAME_CAPTION_WIDTH + 1) + CAMERA_NAME_EDIT_FIELD_WIDTH), 				 m_cyChar * (CAMERA_NAME_EDIT_FIELD_Y + CAMERA_NAME_EDIT_FIELD_HEIGHT));		m_ctlNameEditField.Create(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_TABSTOP | ES_LEFT,								rect, this, IDC_CAMERA_NAME_EDIT_FIELD);	rect.SetRect(m_cxChar * CAMERA_CANCEL_BUTTON_X(LeftCenterLine), 				 m_cyChar * CAMERA_CANCEL_BUTTON_Y, 				 m_cxChar * (CAMERA_CANCEL_BUTTON_X(LeftCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_CANCEL_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlOkButton.Create(CAMERA_CANCEL_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_PUSHBUTTON, rect, this, IDC_CAMERA_CANCEL);	rect.SetRect(m_cxChar * CAMERA_OK_BUTTON_X(RightCenterLine), 				 m_cyChar * CAMERA_OK_BUTTON_Y, 				 m_cxChar * (CAMERA_OK_BUTTON_X(RightCenterLine) + CAMERA_BUTTON_WIDTH), 				 m_cyChar * (CAMERA_OK_BUTTON_Y + CAMERA_BUTTON_HEIGHT));		m_ctlCancelButton.Create(CAMERA_OK_BUTTON_LABEL, 				WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_DEFPUSHBUTTON, rect, this, IDC_CAMERA_OK);	// Set the value of the edit field to the default		m_ctlNameEditField.SetWindowText("No name");	m_ctlNameEditField.SetLimitText(MAX_FILENAME_CHARS);		// Set the checkbox value to the stored default		m_ctlAnimateCheckbox.SetCheck((DisplayGraphics ? BST_CHECKED : BST_UNCHECKED));	m_ctlUpSelectButton.SetFocus();		// Once we are done, send a message to ourselves to start the camera connection	// process. This will guarantee that the window is visible.		PostMessage(EYEDX_MFC_START_CAMERA_MESSAGE, 0, 0);		return 0;}	void CMFCRunFromCameraWin::StartCamera(UINT wParam, LONG lParam){	CWaitCursor wait;		m_ctlUpProgressCaption.SetWindowText("Connecting to camera...");	// Force a refresh of the window to get the window elements to update properly			if (!ConnectToCamera(this, &m_ctlUpProgressCaption, &m_ctlSideProgressCaption, 							&m_ctlUpView, &m_ctlUpCaption, 							&m_ctlSideView, &m_ctlSideCaption,							&m_UpPictInfo, &m_SidePictInfo))	{		OnCancelButtonClicked();	}	else	{		m_ctlUpQualityBitmap.ShowWindow(SW_SHOW);		m_ctlSideQualityBitmap.ShowWindow(SW_SHOW);		// We handle three separate cases here, so that the user sees only one notice, rather than		// possibly two successive ones.				// If the quality isn't what we should be using, warn the user		if ((m_UpPictInfo.PictQuality != DC120BestQuality) || (m_SidePictInfo.PictQuality != DC120BestQuality))		{			// One, or the other or both images are not Best quality. Create an appropriate message						if ((m_UpPictInfo.PictQuality != DC120BestQuality) && (m_SidePictInfo.PictQuality != DC120BestQuality))			{				m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				MessageBox("Neither image was taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake both pictures.", AfxGetAppName());			}			else if (m_UpPictInfo.PictQuality != DC120BestQuality)			{				m_ctlUpQualityBitmap.SetBitmap(m_hCautionBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);				MessageBox("The Up image was not taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake the picture.", AfxGetAppName());			}			else if (m_SidePictInfo.PictQuality != DC120BestQuality)			{				m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);				m_ctlSideQualityBitmap.SetBitmap(m_hCautionBitmap);				MessageBox("The Side image was not taken with the recommended 'Best'\n"							"image quality setting, and analysis may produce incorrect results.\n"							"EyeDx recommends you retake the picture.", AfxGetAppName());			}		}		else		{			m_ctlUpQualityBitmap.SetBitmap(m_hGoodBitmap);			m_ctlSideQualityBitmap.SetBitmap(m_hGoodBitmap);		}				m_ctlUpProgressCaption.SetWindowText(EMPTYSTR);		m_ctlSideProgressCaption.SetWindowText(EMPTYSTR);				m_UpSelected = TRUE;		m_SideSelected = TRUE;	}}// ---------------------------------------------------------------------------------//		¥ HandleCameraImageSelect// ---------------------------------------------------------------------------------// This routine handles display of the select dialog for camera images.void CMFCRunFromCameraWin::HandleCameraImageSelect(SideSelect theSide,  										   CEyeDxDibStatic *theMainWindowView, 										   CStatic *theMainWindowCaption,										   DC120PictInfo *theMainWindowPictInfo,										   CStatic *theMainWindowQualityIcon){		// Create the dialog handler.	CMFCCameraImageSelectDlg dlg(this, theSide,								PictNamePtr, 								NumOfPicts,							   	theMainWindowView, 							   	theMainWindowCaption,							   	theMainWindowPictInfo,							   	theMainWindowQualityIcon,							   	&m_hBadBitmap,								&m_hCautionBitmap,								&m_hGoodBitmap);		if (dlg.DoModal() == IDOK)		return;	return;	}void CMFCRunFromCameraWin::OnSelectUpButtonClicked(){	CMFCRunFromCameraWin::HandleCameraImageSelect(UpImage, &m_ctlUpView, &m_ctlUpCaption, &m_UpPictInfo, &m_ctlUpQualityBitmap);}void CMFCRunFromCameraWin::OnSelectSideButtonClicked(){	CMFCRunFromCameraWin::HandleCameraImageSelect(SideImage, &m_ctlSideView, &m_ctlSideCaption, &m_SidePictInfo, &m_ctlSideQualityBitmap);}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Camera window.// We also set the member that indicates the kind of message to send to // the parent. In the case of OK, we want the parent to go ahead and initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.int CMFCRunFromCameraWin::OnOkButtonClicked(){	// Call the base class to test whether to actually continue		if (CMFCRunWin::OnOkButtonClicked())	{		if (up_image != NULL)		{			free(up_image);			up_image = NULL;			UP_ROWS = UP_COLS = 0;		}				if (side_image != NULL)		{			free(side_image);			side_image = NULL;			SIDE_ROWS = SIDE_COLS = 0;		}				CWaitCursor wait;				m_ctlUpProgressBar.ShowWindow(SW_SHOW);		m_ctlUpProgressCaption.ShowWindow(SW_SHOW);				if (!DownloadImageFromCamera(1,&up_image,&UP_ROWS,&UP_COLS,up_filename, 									this, &m_ctlUpProgressBar, &m_ctlUpProgressCaption))		{			// Handle this the same as a cancel - close the camera and clean up			OnCancelButtonClicked();		}		else		{			m_ctlUpProgressBar.ShowWindow(SW_HIDE);						m_ctlSideProgressBar.ShowWindow(SW_SHOW);			m_ctlSideProgressCaption.ShowWindow(SW_SHOW);						if (!DownloadImageFromCamera(2,&side_image,&SIDE_ROWS,&SIDE_COLS,side_filename, 		 									this, &m_ctlSideProgressBar, &m_ctlSideProgressCaption))							{				// Handle this the same as a cancel - close the camera and clean up				OnCancelButtonClicked();			}			else			{				m_ctlSideProgressBar.ShowWindow(SW_HIDE);								// ALWAYS close the camera!!!								CloseCamera(this);								// Tell ourselves to close, which will send a message to our parent to begin				// analysis				PostMessage(WM_CLOSE, 0, 0);			}		}	}	return 0;}// This function is called when the Ok button is pressed. We send a message// to ourselves which will eventually destroy the Run From Camera window.// We also set the member that indicates the kind of message to send to // the parent. In the case of Cancel, we want the parent not initiate// analysis. We also get our current rectangle on the screen, ans set the// parent window's location to match our's.void CMFCRunFromCameraWin::OnCancelButtonClicked(){	CloseCamera(this);	CMFCRunWin::OnCancelButtonClicked();}