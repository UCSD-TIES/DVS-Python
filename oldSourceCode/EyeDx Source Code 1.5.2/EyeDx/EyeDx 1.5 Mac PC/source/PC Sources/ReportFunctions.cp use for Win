// =================================================================================//	ReportFunctions.cp// =================================================================================//	This file contains the code that handles the Report Functions//#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <limits.h>#include <fcntl.h>#include <ctype.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <StandardFile.h>#include <NumberFormatting.h>#include <LGrowZone.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <UDesktop.h>#include <UDrawingState.h>#include <UMemoryMgr.h>#include <UTextTraits.h>#include <UStandardDialogs.h>#include "LThermometerPane.h"#include "EyeDxMacConstants.h"#include "USubFolderFinder.h"#include <path2fss.h>#include "FileCopy.h"#include "LProgressDialog.h"#include "MoreFiles.h"#include "MoreFilesExtras.h"#include "Mozilla.h"#include "USubfolderFinder.h"extern long DebugFeatures;extern long AdvancedFeatures;#define errInvalidHTML	-31416// ---------------------------------------------------------------------------------//		¥ MyNavObjectFilter// ---------------------------------------------------------------------------------// This routine is called by the File Chooser to filter folders for display. In this// implementation, we do not display the reports folder that is the same as the source// folder. Note that this routine works with both the Standard File dialog and the// new Navigation Services dialogs under 8.5 and beyond. The FSSpec for the source folder// is stored in the static variable below, since we have no other way of getting it into// this routine.//// For StdFile, returning false used to mean that the folder SHOULD be displayed. For NavServices,// returning true means that the folder should be displayed. Since this routine is used for// both, it follows the NavServices convention.static FSSpec sReportDirSpec;static pascal Boolean MyReportFolderNavObjectFilter(AEDesc* inItem, void *info, void* inUserData, NavFilterModes){	LStr255 theFolderName = sReportDirSpec.name;		if (inItem != nil) 	{				// NavServices Callback			NavFileOrFolderInfo *theInfo = (NavFileOrFolderInfo *) info;				// Get info about item from inItem and inInfo  - note that by default		// invisible files are not displayed by Navigation Services.		if (inItem->descriptorType == typeFSS)		{			if (theInfo->isFolder)			{				// Get the name from the input Apple Event Descriptor								FSSpec theFSSpec;								BlockMoveData(*inItem->dataHandle,&theFSSpec,sizeof(FSSpec));								if ((sReportDirSpec.vRefNum == theFSSpec.vRefNum) &&				    (sReportDirSpec.parID == theFSSpec.parID) &&				    (theFolderName.CompareTo(theFSSpec.name) == 0))					return false;				else					return true;		// Return true for folders			}			else					return false;		}	} 	else if (inUserData != nil) 	{		// StandardFile Callback		CInfoPBPtr thePB = (CInfoPBPtr) inUserData;				// If it's invisible, say no				if (thePB->hFileInfo.ioFlFndrInfo.fdFlags & kIsInvisible)			return false;		// If it's a directory, say yes if it's NOT the reports folder!				if (thePB->hFileInfo.ioFlAttrib & ioDirMask)		{			if ((sReportDirSpec.vRefNum == thePB->dirInfo.ioVRefNum) &&				(sReportDirSpec.parID == thePB->dirInfo.ioDrParID))				return false;			else				return true;		}		else			return false;	}	return false;}static void ReportCopyError(OSErr theErr, Str255 theActionString, Str255 theFileString){	Str255 theErrorPrefixStr;	Str255 theErrorNumStr;	Str255 theErrorStr;		LString::CopyPStr("\pCouldn't ", theErrorPrefixStr);	LString::AppendPStr(theErrorPrefixStr, theActionString);	LString::AppendPStr(theErrorPrefixStr, "\p '");	LString::AppendPStr(theErrorPrefixStr, theFileString);	LString::AppendPStr(theErrorPrefixStr, "\p' because");	switch (theErr)	{	case vLckdErr:		LString::CopyPStr("\pthe destination volume is locked.", theErrorStr);		break;			case fLckdErr:	case wPrErr:		LString::CopyPStr("\pthe destination file is locked.", theErrorStr);		break;			case dirFulErr:	case dskFulErr:		LString::CopyPStr("\pthe destination volume or folder is full.", theErrorStr);		break;			case memFullErr:		LString::CopyPStr("\pmemory is full.", theErrorStr);		break;			case errInvalidHTML:		LString::CopyPStr("\pinput file has invalid HTML statements.", theErrorStr);		break;			default:		LString::CopyPStr("\pof error number ", theErrorStr);		::NumToString(theErr, theErrorNumStr);		LString::AppendPStr(theErrorStr, theErrorNumStr);		LString::AppendPStr(theErrorStr, "\p.");	}			::ParamText(theErrorPrefixStr, theErrorStr, "\pCancelling Export Report operation.", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);}struct FSSpecPairList{	FSSpec	theSrcSpec;	FSSpec	theDstSpec;};					const char *theSRCTokenString = "SRC";// The buffer we are passed in ptr is NULL-terminated. So we can just parse the entire buffer as// one big string.					static OSErr ParseForSRCTags(char *ptr, FSSpecPairList **theFSSpecPairList, long *theFSSpecListCount, 						FSSpec *theSourceReportsSpec, 						FSSpec *theDestinationSImagesSpec, FSSpec *theDestinationEyesSpec){	// Scan through the provided buffer, looking for patterns that look like 'SRC[ ]=[ ]"string"'		// Save the pointer		char *p = ptr;		// NULL the pointer to the FSSpecPairList, and set the count to zero		*theFSSpecPairList = NULL;		*theFSSpecListCount = 0;		// Get the first token		char *theSRCToken = strstr(p, theSRCTokenString);		while (theSRCToken)	{		p = theSRCToken + 1;			// We found a token. Now look for an equals sign, a double quote, a newline, or a return		// Any of these are terminations for the SRC token. Only the equals sign is valid. Note		// That we may have just found a "SRC" string embedded in the report name, so we do not		// consider this an error. We just move on to the next token.				char *theFollowingToken = strpbrk(p, "=\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '='))		{			// Now get the next SRC token			theSRCToken = strstr(p, theSRCTokenString);			continue;		}				p = theFollowingToken + 1;				// Ok, we've found the '='. Now look for an opening double quote		// In this case, if it is not found, we have a string that looks like		// "SRC=" but is not an HTML tag. This could be a valid string in the		// report name, for example. So, we just move on. Since double quotes are		// illegal in report names, from this point on we must be dealing with an HTML		// tag, and handle invalid cases as errors.				theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			// Now get the next SRC token			theSRCToken = strstr(p, theSRCTokenString);			continue;		}					p = theFollowingToken + 1;				// Now we are pointing at the opening double quote. We bump the pointer		// up, and save the starting pointer for the URL (which should be a file reference -		// if not, we ignore it				char *theStartOfURL = p;				// Now, look for a valid terminating double quote. If we don't find it before hitting		// the end of the buffer or a newline or carriage return, its an error		theFollowingToken = strpbrk(p, "\n\r\"");		if ((theFollowingToken == NULL) || (*theFollowingToken != '"'))		{			if (*theFSSpecPairList)				free(*theFSSpecPairList);			return errInvalidHTML;		}		// We can now calculate the length of the URL string. It is theFollowingToken - theStartofURL		// We use this to copy the URL into an allocated string, and tack-on a terminating NULL.				long theURLSize = theFollowingToken - theStartOfURL;		char *theURL = new char [theURLSize + 1];				strncpy(theURL, theStartOfURL, theURLSize);		theURL[theURLSize] = '\0';				p = theFollowingToken + 1;		// Finally, we have extracted the URL from the text. We attempt to convert it into a FSSpec.		// We have to determine the directory portion. It should be either "Simages" or "eyes". If		// neither of these strings exist in the URL, we simply ignore it. This takes care of the		// logo file. Of course, it breaks if new directories are added to the EyeDx hierarchy, but		// so does other portions of the EyeDx code that deal only with the know directories.				// Note that the input FSSpec for the conversion routine is the reports directory. It will		// resolve the actual directory based on the UNIX path.				CEyeDxBooleanType theCreateFlag = false;		FSSpec theInSpec = *theSourceReportsSpec;		FSSpec theOutSpec;				if (strstr(theURL, "Simages") != NULL)		{			theOutSpec = *theDestinationSImagesSpec;			theCreateFlag = true;		}		else		if (strstr(theURL, "eyes") != NULL)		{			theOutSpec = *theDestinationEyesSpec;			theCreateFlag = true;		}					if (theCreateFlag)		{			// It's an SImages file. So we build the FSSpec using the passed-in 						// Skip over any leading "../" or "./" strings, so that the URL is relative to			// the application directory, not the reports directory.						char *theURLptr = theURL;						while (*theURLptr == '.' || *theURLptr == '/')				theURLptr++;							FSSpecFromLocalUnixPath(theURLptr, &theInSpec, true);						// We now have the FSSpec for the source file. Copy the name to the destination			// spec.						LString::CopyPStr(theInSpec.name, theOutSpec.name);						// Now we have the in and out spec. Create another element in the output list.			// First, bump the count of elements. The tack on space on the end of the array,			// and then copy in the FSSpecs we just created.						(*theFSSpecListCount)++;						FSSpecPairList *theList = *theFSSpecPairList;						theList = (FSSpecPairList *)realloc(theList, sizeof(struct FSSpecPairList) * (*theFSSpecListCount));						*theFSSpecPairList = theList;						theList[*theFSSpecListCount - 1].theSrcSpec = theInSpec;			theList[*theFSSpecListCount - 1].theDstSpec = theOutSpec;		}							// We don't need the string anymore, so delete it				delete theURL;				// Now get the next SRC token		theSRCToken = strstr(p, theSRCTokenString);		}	return noErr;}					void CDocumentApp::HandleExportReports(){	OSErr makeErr;		// Create the subfolders in case the user renamed them		CreateFolders();				// First, have the user choose one or more reports to export		PP_PowerPlant::LFileTypeList	theTEXTFileTypes('TEXT');	// We also build temporary file chooser objects using the Standard File dialogs		PP_PowerPlant::PP_StandardDialogs::LFileChooser	theReportChooser;	PP_PowerPlant::PP_StandardDialogs::LFileChooser	theDestinationChooser;	FSSpec theReportSpec;		theReportChooser.SetDefaultLocation(mReportDirSpec, FALSE);		// Set the local static 'global' so that the call back can compare the folders to be	// displayed with the source files. They should not be the same!	makeErr = ::FSMakeFSSpec(mApplSpec.vRefNum, mApplSpec.parID, Str_Empty, &sReportDirSpec);			// Don't filter just the files created by the current browser selection! We will accept any	// text files.#if FALSE	if (mBrowserCreatorCode == kUnknownType)		if (!CDocumentApp::HandlePreferences())			return;					// Cancel the operation if they canceled the selection of Browser	theTEXTFileTypes.SetSignature(mBrowserCreatorCode);	// We look for those created by the specified browser#endif		// Turn off the option to display previews, since previewing HTML doesn't make sense		NavDialogOptions	*options = theReportChooser.GetDialogOptions();	if (options != nil) 	{		options->dialogOptionFlags =	kNavDontAddTranslateItems +		/* don't add translation choices on Open/Save */												kNavSelectAllReadableItem +			/* allow saving of stationery files */												kNavAllowMultipleFiles +												kNavNoTypePopup;				LString::CopyPStr("\pEyeDx: Choose Reports", options->windowTitle);		LString::CopyPStr("\pChoose", options->actionButtonLabel);	}		// Note that we allow multiple files to be selected if using Navigation Services. That's	// why we use AskChooseFile. We will ask the chooser the count and then retrieve the list in the	// loop below. If StdFile is used, we will only get one item.												 	CEyeDxBooleanType openOK = theReportChooser.AskOpenFile(theTEXTFileTypes);					if (openOK)	{		// Next, if the user chose a report, ask them to select a destination. This		// should be a folder or volume.				SInt32 theFolderID;		FSSpec theDestinationSpec;				// Unfortunately, there isn't really a good default location. We don't want them to 		// choose the reports folder in the application's directory. However, Standard File		// doesn't really allow us to do that. It doesn't call the filter proc for an empty		// directory, for example. So perhaps the best place to default to is the Desktop.				short foundVRefNum;		long foundDirID;				makeErr = ::FindFolder(mApplSpec.vRefNum, kDesktopFolderType, false, &foundVRefNum, &foundDirID);										FSSpec theDefaultDestination;				makeErr = ::FSMakeFSSpec(foundVRefNum, foundDirID, Str_Empty, &theDefaultDestination);					theDestinationChooser.SetDefaultLocation(theDefaultDestination, FALSE);			// If we are running with Navigation Services, we use the Chooser dialog strings to		// inform the user what we are doing. Otherwise, with StdFile, we put up a prompt.		NavDialogOptions	*options = theDestinationChooser.GetDialogOptions();		if (options != nil) 		{			LString::CopyPStr("\pEyeDx: Choose export folder", options->windowTitle);		}#if	PP_StdDialogs_Option == PP_StdDialogs_Conditional		if (!UConditionalDialogs::UseNavServices())#endif#if PP_StdDialogs_Option != PP_StdDialogs_NavServicesOnly 		{			 ::ParamText("\pSelect the export folder where report will be written.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::NoteAlert(PPob_GeneralALRT);		}#endif		// Set up the filter proc for theImageChooser to filter-out the source reports folder.				theDestinationChooser.SetObjectFilterProc((NavObjectFilterProcPtr) MyReportFolderNavObjectFilter);		openOK = theDestinationChooser.AskChooseFolder(theDestinationSpec, theFolderID);								if (openOK)		{			// If a folder or volume is chosen, then we process each report that was chosen.			// The first step is to copy the EyeDxLogo.jpg file into the root directory of the destination			// folder.						// Note that we MUST copy something into the destination folder, so that, in turn, we can call the			// USubFolderFinder class. The class creates an alias of something that resides in the folder, so			// if it is empty, it doesn't work. Argh.						// We modify the destination spec so that we get the spec of an actual file within the folder itself. This is necessary			// because the USubFolderFinder class needs a file in the folder to create an alias. An empty folder doesn't			// cut it. So, we use the EyeDxLogo.jpg file, since that is what we want to create right now.			makeErr = ::FSMakeFSSpec(theDestinationSpec.vRefNum, theFolderID, "\pEyeDxLogo.jpg", &theDestinationSpec);			// Try to delete the destination file. If it already exists, the FileCopy routine will complain and not			// overwrite it. So, we try to delete it whether or not exists, and ignore the result of the delete.						makeErr = ::FSpDelete(&theDestinationSpec);						makeErr = FileCopy(mApplSpec.vRefNum, mApplSpec.parID, "\pEyeDxLogo.jpg",							   theDestinationSpec.vRefNum, theFolderID, nil, nil, nil, 0L, true);			if (makeErr != noErr)			{				ReportCopyError(makeErr, "\pcopy", "\pEyeDxLogo.jpg");				return;			}										// Next, create the subfolders (reports, Simages, eyes) if necessary						USubfolderFinder theFolderFinder;						theFolderFinder.Initialize(&theDestinationSpec);	// We pass in the destination directory to use as the root						// Create an FSSpec for each of the subdirectories (where the application lives). If the specified			// folder doesn't exit, the Folder Finder object will create it.						FSSpec theDestinationReportsSpec;			FSSpec theDestinationSImagesSpec;			FSSpec theDestinationEyesSpec;			LString::CopyPStr("\preports", theDestinationReportsSpec.name);					if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationReportsSpec.name, theDestinationReportsSpec.parID, theDestinationReportsSpec.vRefNum)) != noErr)				ThrowOSErr_(makeErr);			LString::CopyPStr("\pSimages", theDestinationSImagesSpec.name);						if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationSImagesSpec.name, theDestinationSImagesSpec.parID, theDestinationSImagesSpec.vRefNum)) != noErr)				ThrowOSErr_(makeErr);			LString::CopyPStr("\peyes", theDestinationEyesSpec.name);						if ((makeErr = theFolderFinder.FindFolderNamed(theDestinationEyesSpec.name, theDestinationEyesSpec.parID, theDestinationEyesSpec.vRefNum)) != noErr)				ThrowOSErr_(makeErr);								// Next, for each file that was selected, copy the file into the reports folder. Then, 			// look into the file for all SRC tags. Error handling consists of making a list of the files			// associated with each report that are copied. If an error occurs, such as running out of disk			// space, the program will remove the last report and the lartial list of associated files from			// the destination. This is so that partial reports are not accidentally exported.						SInt32 theNumReports = theReportChooser.GetNumberOfFiles();						// Create a LProgressDialog to show progress as we copy						LProgressDialog theProgressDialog("\pExport Reports", this);			// Now, show the progress dialog						theProgressDialog.SetTaskType(task_Measured);			theProgressDialog.SetValues(0, theNumReports, 0);			theProgressDialog.Show();						// Note that the reports are numbered started at 1			for (SInt32 theReportNum = 1; theReportNum <= theNumReports; theReportNum++)			{							FSSpec theReportCopySpec;								// Get the file, and copy it, first confirming overwrite if the destination exists								theReportChooser.GetFileSpec(theReportNum, theReportSpec);								// Show progress in the dialog as we copy								Str255 theActionStr;				Str255 theCountStr;				Str255 theStepStr;				Str255 theNumStr;								LString::CopyPStr("\pExporting ", theActionStr);				LString::AppendPStr(theActionStr, theReportSpec.name);				theProgressDialog.SetActionDescriptor(theActionStr);								LString::CopyPStr("\pCopying ", theStepStr);				LString::AppendPStr(theStepStr, theReportSpec.name);				theProgressDialog.SetStepDescriptor(theStepStr);								::NumToString(theReportNum, theCountStr);				LString::AppendPStr(theCountStr, "\p of ");				::NumToString(theNumReports, theNumStr);				LString::AppendPStr(theCountStr, theNumStr);				theProgressDialog.SetCountDescriptor(theCountStr);								ProcessNextEvent();				// Copy the file into the reports folder in the destination. First, check if it already exists.				// If it does, prompt the user to overwrite or skip this file.								makeErr = ::FSMakeFSSpec(theDestinationReportsSpec.vRefNum, theDestinationReportsSpec.parID, theReportSpec.name, &theReportCopySpec);								FInfo theFInfo;								makeErr = FSpGetFInfo(&theReportCopySpec, &theFInfo);				// Assume that the default is yes.				DialogItemIndex item_hit = PPob_YesNoALRT_Yes;				if (makeErr == noErr)				{					Str255 theQuotedNameStr;					LString::CopyPStr("\p'", theQuotedNameStr);					LString::AppendPStr(theQuotedNameStr, theReportSpec.name);					LString::AppendPStr(theQuotedNameStr, "\p'");					 ::ParamText("\pA report named", theQuotedNameStr, "\palready exists in the export folder.", "\pOverwrite?");					item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);					if (item_hit == PPob_YesNoALRT_Yes)					{														makeErr = ::FSpDelete(&theReportCopySpec);						if (makeErr != noErr)						{							ReportCopyError(makeErr, "\pdelete", theReportSpec.name);							theProgressDialog.Hide();							return;						}					}				}				else				if (makeErr != fnfErr)				{					ReportCopyError(makeErr, "\paccess", "\pthe export folder");					return;				}				// else the file didn't exist, and that's just swell. 						if (item_hit == PPob_YesNoALRT_Yes)				{													// Copy the report file										makeErr = FileCopy(theReportSpec.vRefNum, theReportSpec.parID, theReportSpec.name,							  		   theReportCopySpec.vRefNum, theReportCopySpec.parID, nil, nil, nil, 0L, true);									   					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pcopy", theReportSpec.name);						return;					}										// Now parse the report file looking for SRC tags.										// To simplify things, we just read the entire report file into temporary memory. Since report					// files are small (or should be!), this shouldn't be a problem. Note that we check to make sure					// that there is sufficient memory available to do this.										long theFileDataSize;					long theFileRsrcSize;										makeErr = FSpGetFileSize(&theReportSpec, &theFileDataSize, &theFileRsrcSize);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						return;					}										// We will NULL-terminate the read buffer, so bump its size up by one byte										Handle theMemoryHandle = ::TempNewHandle((theFileDataSize + 1), &makeErr);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						return;					}																// Lock the handle so we can dereference it										::HLock(theMemoryHandle);												char *thePointer = *theMemoryHandle;										short refNum;					makeErr = FSpOpenDF(&theReportSpec, fsCurPerm, &refNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						return;					}										// Read the file, looking for the SRC = "URL" tags.					makeErr = FSRead(refNum, &theFileDataSize, thePointer);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pread", theReportSpec.name);						return;					}										// NULL terminate the buffer, so that the string functions we use in the					// parse function won't run off the end.										thePointer[theFileDataSize] = '\0';					// Parse the memory, and build a list of FSSpecs that represent					// image files that need to be copied, minus the logo file. We pass					// in the FSSpecs for the destination SImages and eyes folder.										FSSpecPairList *theFSSpecPairList;					long theFSSpecListCount;										makeErr = ParseForSRCTags(thePointer, &theFSSpecPairList, &theFSSpecListCount, 											&mApplSpec,											&theDestinationSImagesSpec, &theDestinationEyesSpec);										if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pparse", theReportSpec.name);						return;					}					// Close the file										makeErr = FSClose(refNum);					if (makeErr != noErr)					{						ReportCopyError(makeErr, "\pclose", theReportSpec.name);						return;					}										// Unlock the handle and release the temporary memory, since we are done parsing.										::HUnlock(theMemoryHandle);					::DisposeHandle(theMemoryHandle);										// For each SRC tag found, convert the path into a file reference, and copy the 					// file into the appropriate subfolder in the destination folder.										// Point to the first element in the list										FSSpecPairList *theImagePairSpec = theFSSpecPairList;										// We have two choices for handling any existing files in the destination folder.					// Since the current naming scheme doesn't tie an image to a report, if we delete the					// images we may be changing the contents of other reports that also used this image					// previously. The alternative is to prompt the user to tell them that these images					// exist, and if they say to overwrite, we do so. If they say to skip, then we presumably					// remove the report file that we just copied.															// However, the alternative is to just delete any existing duplicate names in the destination					// and tell the user that we had to do that.										// Neither is ideal. The image naming scheme should really use the name of the report in the					// file name so that if we see a duplicate, we know that we are replacing images for the					// report that the user just confirmed overwriting. 										// Right now, we take the easy way out, and just delete the offending files.										// Assume that the answer is yes.					DialogItemIndex item_hit = PPob_YesNoALRT_Yes;#if FANCYOVERWRITETEST						// First check to see if any of the destination files already exist. If so, append the string					// names to a prompt string, and ask the user to confirm overwriting.										long theDuplicateFileCount = 0;															for (long theImageFile = 0; theImageFile < theFSSpecListCount; theImageFile++)					{						FInfo theFInfo;										makeErr = FSpGetFInfo(&theImagePairSpec->theDstSpec, &theFInfo);												if (makeErr == dupFNErr)							theDuplicateFileCount++													theImagePairSpec++;					}										if (theDuplicateFileCount != 0)					{							Str255 theCountStr;							if (theDuplicateFileCount == 1)							{								LString::AppendPStr(theCountStr, "\pOne image file for report '");								LString::AppendPStr(theCountStr, theReportSpec.name);								LString::AppendPStr(theCountStr, "\p' already exists");							}							else							{								::NumToString(theDuplicateFileCount, theCountStr);								LString::AppendPStr(theCountStr, "\p images file for report '");								LString::AppendPStr(theCountStr, theReportSpec.name);								LString::AppendPStr(theCountStr, "\p' already exist");							}							::ParamText(theCountStr, "\p in the export folder.", "\pOverwrite?", "\'No' will skip copying this report");							item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);						}					}#endif					if (item_hit == PPob_YesNoALRT_Yes)					{								// Point back to the start of the list												theImagePairSpec = theFSSpecPairList;															for (long theImageFile = 0; theImageFile < theFSSpecListCount; theImageFile++)						{							FInfo theFInfo;												makeErr = FSpGetFInfo(&theImagePairSpec->theDstSpec, &theFInfo);														// For each file that is actually a duplicate in the destination folder,							// try to delete it. noErr means that the destination file exists. We							// ignore other errors, as they will be caught by the attempt to delete							// the file.														if (makeErr == noErr)							{								LString::CopyPStr("\pDeleting ", theStepStr);								LString::AppendPStr(theStepStr, theImagePairSpec->theDstSpec.name);								LString::AppendPStr(theStepStr, "\p in the export folder");								theProgressDialog.SetStepDescriptor(theStepStr);								ProcessNextEvent();																makeErr = ::FSpDelete(&theImagePairSpec->theDstSpec);								if (makeErr != noErr)								{									ReportCopyError(makeErr, "\pdelete", theImagePairSpec->theDstSpec.name);									theProgressDialog.Hide();									return;								}							}													LString::CopyPStr("\pCopying ", theStepStr);							LString::AppendPStr(theStepStr, theImagePairSpec->theSrcSpec.name);							theProgressDialog.SetStepDescriptor(theStepStr);							ProcessNextEvent();														makeErr = FileCopy(theImagePairSpec->theSrcSpec.vRefNum, theImagePairSpec->theSrcSpec.parID, theImagePairSpec->theSrcSpec.name,							  		   		theImagePairSpec->theDstSpec.vRefNum, theImagePairSpec->theDstSpec.parID, nil, nil, nil, 0L, true);									   											   							if (makeErr != noErr)							{								ReportCopyError(makeErr, "\pcopy", theImagePairSpec->theSrcSpec.name);								return;							}										// Move to the next image pair														theImagePairSpec++;												}					}#if FANCYOVERWRITETEST						else					{						// We should delete the report file, since the user has told us to skip copying it						// Unfortunately, we have no guarantee that the images that we detected as being duplicates						// have anything to do with the original report! So the user may end up with a destination						// with the original images and no report. That's ok if the images are used by some other						// reports. But they are orphaned if the overwritten report was the only one to use them						// and the user elected to skip copying the images when prompted. Argh.																		makeErr = ::FSpDelete(&theReportCopySpec);					}#endif										// Delete the memory allocated for the image list										if (theFSSpecPairList != nil)						free((void *)theFSSpecPairList);				}								// Check to see if the user hit the Cancel button. If so, we should clean up the current				// report				if (theProgressDialog.IsStopClicked())				{					LString::CopyPStr("\pCanceling...", theStepStr);					theProgressDialog.SetStepDescriptor(theStepStr);					ProcessNextEvent();									// No cleanup for the last report since we complete each report before checking for Cancel										return;				}								// Otherwise, indicate that we completed yet another report								theProgressDialog.CompletedThisMuchMore(1);			}					}	}}// This routine will check the passed filename string for any of the illegal// filename characters. We use a common set of illegal characters for both// platforms, so that files can easily be exchanged between systems.static CEyeDxBooleanType LegalFilename(const CEyeDxShortStringType &theString){	Str255 anotherString;	LString::CopyPStr(theString, anotherString);	p2cstr(anotherString);		if (strpbrk((char *)anotherString, ILLEGAL_FILENAME_CHARS) != NULL)		return FALSE;	return TRUE;}// This routine checks if the specified report exists, and prompts the user// for what to do. It also checks the report string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.// It also updates the global report_filename variable.Boolean CDocumentApp::CheckReportValidity(CEyeDxShortStringType *theReportNameString){	// Make a copy		CEyeDxShortStringType anotherReportString = *theReportNameString;		CEyeDxVariable *theSessionNameVariable = mVariableList.GetVariableByName(CommonStringLiteral_(kCEyeDxVariableSESSIONNAME));		CEyeDxLongStringType *theSessionName = theSessionNameVariable->GetValue();	// Convert into a C string for use in the open statements below		char sessionName[256];	strncpy(sessionName, theSessionName->TextPtr(), theSessionName->Length());	sessionName[theSessionName->Length()] = '\0';							// Perform some validity checks on the report name		long theReportNameLength = (*theReportNameString)[0];	unsigned char *theReportNameBuffer = &(*theReportNameString)[1];	int theMaxReportNameLength = kMaxReportNameLength;		// If the adjustName option is turned on, we have to account for the prefix length	// when testing the maximum report name length.		if (mReportPrefs.adjustName)		theMaxReportNameLength -= kPrefixLength;		if (theReportNameLength == 0)	{				::ParamText("\pPlease enter a report name.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (theReportNameLength > theMaxReportNameLength)	{		Str255 theLengthStr;		::NumToString(theMaxReportNameLength, theLengthStr);				::ParamText("\pThe report name is too long (maximum", theLengthStr, "\pcharacters).", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (!LegalFilename(anotherReportString))	{			::ParamText("\pThe report name cannot contain any of the characters ", CommonStringLiteral_(ILLEGAL_FILENAME_CHARS), Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else	{		strncpy(report_filename, (char *)theReportNameBuffer, (unsigned long)theReportNameLength);		report_filename[theReportNameLength] = '\0';				// Check if this report already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				if (mReportPrefs.adjustName)		{			char *prefixes[] = {kYesReferralIndicator, 								kNoReferralIndicator,								kSecondImageReferralIndicator,								kUnclearReferralIndicator };						char theFileList[200];			strcpy(theFileList, "");			int existingReports = 0;			for (int prefixNum = 0; prefixNum < kNumValidPrefixes; prefixNum++)			{								char reportpath[100];				sprintf(reportpath, ":%s:reports:%s%s.htm", sessionName, prefixes[prefixNum], report_filename);				int fp;				// Default to the "yes" condition				DialogItemIndex item_hit = PPob_YesNoALRT_Yes;							if ((fp = open(reportpath, O_EXCL | O_RDONLY)) != -1)				{					close(fp);					existingReports++;					if (strlen(theFileList) != 0)						strcat(theFileList, ", ");					strcat(theFileList, "'");					strcat(theFileList, prefixes[prefixNum]);					strcat(theFileList, report_filename);					strcat(theFileList, "'");				}			}						if (existingReports > 0)			{				LStr255 thePrompt(theFileList);				thePrompt.Append("\p.");								if (existingReports == 1)					::ParamText("\pA report with this name and a referral prefix exists in this session: ", thePrompt,							"\pShould the program overwrite it if necessary?", Str_Empty);				else					::ParamText("\pReports with this name and referral prefixes exist in this session: ", thePrompt,							"\pShould the program overwrite one of these if necessary?", Str_Empty);								DialogItemIndex item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);				if (item_hit == PPob_YesNoALRT_Yes)					return true;				else					return false;			}			return true;		}		else		{					char reportpath[100];			sprintf(reportpath, ":%s:reports:%s.htm", sessionName, report_filename);			int fp;			// Default to the "yes" condition			DialogItemIndex item_hit = PPob_YesNoALRT_Yes;						if ((fp = open(reportpath, O_EXCL | O_RDONLY)) != -1)			{				close(fp);				 ::ParamText("\pA report with this name already exists in this session.", "\pOverwrite?", Str_Empty, Str_Empty);				item_hit = UModalAlerts::CautionAlert(PPob_YesNoALRT);			}			if (item_hit == PPob_YesNoALRT_Yes)				return true;			else				return false;		}	}	return false;		}OSErr CDocumentApp::OpenReport(FSSpec *theReportSpec){		OSErr openErr = OpenSpecifiedDocument(theReportSpec, mBrowserCreatorCode);	if (openErr != noErr)	{		switch (openErr)		{		case memFullErr:		case appMemFullErr:	 		::ParamText("\pNot enough memory available to start the browser.", 	 					"\pExit the EyeDx program and open the report by double clicking on the report file icon", 	 					Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);					break;					default:	 		::ParamText("\pCould not start the browser.", 	 					"\pIs it installed?", "\pIs there sufficient memory available to run the browser?", 	 					Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);		}	}		return (openErr);}// This routine checks if the specified session exists, and prompts the user// if so. It also checks the session name string for length and illegal// characters, and displays a notice if appropriate.// Returns true if the operation should continue, and false if not.CEyeDxBooleanType CheckSessionValidity(CEyeDxWindowType *theWindow, CEyeDxLongStringType *theSessionNameString){	// Convert into a C string for use in the open statements below		char sessionName[256];	strncpy(sessionName, theSessionNameString->TextPtr(), theSessionNameString->Length());	sessionName[theSessionNameString->Length()] = '\0';							// Perform some validity checks on the session name		if (theSessionNameString->Length() == 0)	{				::ParamText("\pPlease enter a session name.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (theSessionNameString->Length() > kMaxSessionNameLength)	{		Str255 theLengthStr;		::NumToString(kMaxSessionNameLength, theLengthStr);				::ParamText("\pThe session name is too long (maximum", theLengthStr, "\pcharacters).", Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else if (!LegalFilename(*theSessionNameString))	{			::ParamText("\pThe session name cannot contain any of the characters ", CommonStringLiteral_(ILLEGAL_FILENAME_CHARS), Str_Empty, Str_Empty);		UModalAlerts::StopAlert(PPob_GeneralALRT);	}	else	{		// Check if this session already exists. If it does, prompt the user whether to continue		// If the adjustName feature is enabled, we have to loop through the possible prefixes, and		// warn the user that a possible conflict exists. Otherwise, just check for the same exact name.				CEyeDxLongStringType theSessionPath = LEADINGPATHSEPARATOR;		theSessionPath += *theSessionNameString;				if (USubfolderFinder::DoesFolderNamedExist(theSessionPath) == noErr)		{			::ParamText("\pA session with this name already exists.", Str_Empty, Str_Empty, Str_Empty);			UModalAlerts::StopAlert(PPob_GeneralALRT);			return false;		}		return true;	}	return false;		}// This routine will parse the specified session folder, generating a list of report names. It then sorts the// list alphabetically, and returns it and the number of elements to the caller. The list must be a C String// list because it is called by cross-platform common code. The caller is responsible for freeing the allocated// memoryconst short kMaxItemsPerCall = 2000;CTemplateShortStrArray *GetReportList(CEyeDxLongStringType *theSessionName, short *numReports){	// We use the MoreFiles routine GetDirItems routine. It generates a list	// of FSSpecs for the items in the directory we specify. We then transfer this	// list over to a list of C strings.		CEyeDxLongStringType theReportsFolder = "\p:";	theReportsFolder += *theSessionName;	theReportsFolder += "\p:reports";		FSSpec **items;	CTemplateShortStrArray *tmpStringArray = nil;	OSErr theErr;		// By default, make sure that the numReports variable is zero in case of error		*numReports = 0;		FSSpec			spec;	Boolean			wasChanged;	Assert_(USubfolderFinder::sApplicationAliasH != nil);		if (( theErr = ::ResolveAlias(nil, USubfolderFinder::sApplicationAliasH, &spec, &wasChanged)) == noErr) 	{		short theNextItem = 1;		short numFiles;				// We allocate the array of FSSpec structures to be filled-in by the call		items = (FSSpec **) ::TempNewHandle(kMaxItemsPerCall * sizeof(FSSpec), &theErr);				::HLock((Handle)items);				theErr = GetDirItems(spec.vRefNum,							spec.parID,							theReportsFolder,		// The name of the session folder							true,					// We are interested in files only							false,					// Shouldn't be any subdirectories but don't request them anyway							*items,					// Pointer to array of FSSpec objects							kMaxItemsPerCall,		// We want as many as there can be!							&numFiles,				// We'll get the count here							&theNextItem);			// Start with the first item				 // fnfErr is a normal return from the routine! It just indicates that we requested more files		 // than exist in the directory. No biggie.		 		if ((theErr == noErr) || (theErr == fnfErr))		{			*numReports = numFiles;						if (*numReports > 0)			{				// First, we create a sorted string array which will automatically sort as we insert the strings.								tmpStringArray = new CTemplateShortStrArray(CCEyeDxLongStringTypeComparator::GetComparator(), true);				short itemNum = 0;				FSSpec *theSpecs = *items;												CEyeDxShortStringType *theString;								while (itemNum < *numReports)				{					CEyeDxShortStringType *theStringCopy = new CEyeDxShortStringType(theSpecs[itemNum].name);										// We strip-off the ".htm" extension										const short kLengthOfHTMExtension = 4;										short startPos = theStringCopy->ReverseFind("\p.htm");										if (startPos != 0)					{						LString::Remove(startPos, kLengthOfHTMExtension);					}					tmpStringArray->Add(theStringCopy);				}								// Now, we have a sorted list! 					#if FALSE // Use for Windows				stringArray = new char * [*numReports];								short itemNum = 0;								FSSpec *theSpecs = *items;								while (itemNum < *numReports)				{					// Allocate space for the C string based on the length of the Pascal string for the item										short theLength = theSpecs[itemNum].name[0];					char *p = stringArray[itemNum] = new char [theLength + 1];					strncpy(p, (char *)&theSpecs[itemNum].name[1], theLength);					p[theLength] = '\0';											// Convert the report filename into a filename w/o the ".htm" extension. 										char theExtension[63];										// Since filenames can contain multiple "." characters, we find the location of					// the _last_ one. Then we see if the following string is 'htm'.					// (upper or lower case. If not, we just copy the entire string.					// If the extension is 'htm', then we truncate the string at the ".".										char *lastperiod = strrchr(p, '.');					if (lastperiod != NULL)					{						// Copy the extension, and convert to lower case to make comparison						// easy												char *p = lastperiod + 1;						char *e = &theExtension[0];												while (*p)							*e++ = tolower(*p++);												*e = '\0';												// If the extension is 'htm', then truncate the string at the period.												if (strcmp(theExtension, "htm") == 0)							*lastperiod = '\0';					}													itemNum++;				}								// Now, we sort the list in alphabetical order				#endif			}						// Free the spec memory						::HUnlock((Handle)items);			::DisposeHandle((Handle)items);		}		}	return tmpStringArray;}