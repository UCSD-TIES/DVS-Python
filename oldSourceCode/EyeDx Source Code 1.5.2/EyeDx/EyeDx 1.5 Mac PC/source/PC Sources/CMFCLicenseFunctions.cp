// =================================================================================//	LicenseFunctions.cp					©1999 EyeDx, Inc. All rights reserved.// =================================================================================#include <stdio.h>#include <unistd.h>#include <stdlib.h>#include <string.h>#include <fcntl.h>// This file includes the global variables used to interface with the C code// ported from the PC. It also defines some of the debugging macros#include "globals.h"#include "CDocumentApp.h"#include <NumberFormatting.h>#include <PP_Messages.h>#include <PP_Resources.h>#include <PPobClasses.h>#include <UStandardDialogs.h>#include <LWindow.h>#include <LGroupBox.h>#include <LTextButton.h>#include "LThermometerPane.h"#include "EyeDxMacConstants.h"#include "ABalloon.h"#include "FileCopy.h"const Str255	kLicenseFileName = "\pEyeDxMisc";void CDocumentApp::GetLicenseExpDateString(LStr255 &theString){	// We use the international utilities to format the date as expected for the locale		DateTimeRec theDateRec;		EyeDxLicenseInfo::DecodeDateCode(mLicenseExpDateCode, theDateRec.year, theDateRec.month, theDateRec.day);	theDateRec.hour = 23;	theDateRec.minute = 59;	theDateRec.second = 59;	theDateRec.dayOfWeek = 1;	// Dummy value		unsigned long theSeconds;		DateToSeconds(&theDateRec, &theSeconds);		::DateString(theSeconds, shortDate, theString, nil);}void CDocumentApp::GetLicenseCountString(LStr255 &theString){	theString = (long) mLicenseCount;}void CDocumentApp::SetLicenseStatusCaption(LCaption *theCaption){	// Display the license status		LStr255 theStatusLine;	LStr255 theString;		GetLicenseCountString(theStatusLine);			theStatusLine.Append(" Runs Remaining, Valid Through ");		GetLicenseExpDateString(theString);		theStatusLine.Append(theString);		theStatusLine.Append("\p.");	theCaption->SetDescriptor(theStatusLine);			}void CDocumentApp::HandleLicenseDisplay(enum LicenseStatus theStatus){	if (theStatus == LicenseStatusNotInstalled)	{		::ParamText("\pThere is no license installed.", Str_Empty, Str_Empty, Str_Empty);		UModalAlerts::NoteAlert(PPob_GeneralALRT);		return;	}		// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseStatusDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		LCaption *theExpDate = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kLicenseStatusExpDate));	ThrowIfNil_( theExpDate );		LCaption *theAnalysisRuns = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kLicenseStatusAnalysisRuns));	ThrowIfNil_( theAnalysisRuns );	LCaption *theCaption = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kLicenseStatusCaption));	ThrowIfNil_( theCaption );	LStr255 theDateStatusString;	LStr255 theCountStatusString;	LStr255 theDateString;	LStr255 theCountString;		GetLicenseExpDateString(theDateString);	GetLicenseCountString(theCountString);		// By default, set the output strings to the returned values		theDateStatusString = theDateString;	theCountStatusString = theCountString;	switch (theStatus)	{	case LicenseStatusExpiredDate:		theDateStatusString = "\pExpired on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with a new expiration date (and additional runs, if desired). The remaining run count will be added to the amount in the new license.");		break;	case LicenseStatusExpiredCount:		theDateStatusString = "\pPrevious license was valid through " + theDateString + "\p.";		theCountStatusString = "\pNo Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with additional runs.");		break;	case LicenseStatusExpiredBoth:		theDateStatusString = "\pExpired on " + theDateString + "\p.";		theCountStatusString = "\pNo Analysis Runs Remaining.";		theCaption->SetDescriptor("\pRequest a new license with additional runs and a new expiration date.");		break;	case LicenseStatusDateOutOfRange:		theDateStatusString = "\pValid through midnight on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Remaining.";		theCaption->SetDescriptor("\pThe system clock appears to have been reset - license not currently valid.");		break;	default:		theDateStatusString = "\pValid through midnight on " + theDateString + "\p.";		theCountStatusString = theCountString + "\p Analysis Runs Available.";		theCaption->SetDescriptor("\pYour license is currently valid.");		break;	}		theExpDate->SetDescriptor(theDateStatusString);		theAnalysisRuns->SetDescriptor(theCountStatusString);	// Make the dialog visible.	theDialog->Show();		bool done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{					case msg_OK: 			done = true;			break;		}	}}void CDocumentApp::HandleLicenseExpired(enum LicenseStatus inLicenseStatus){	// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseExpiredDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		LCaption *thePrompt = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kLicenseExpiredPrompt));	ThrowIfNil_( thePrompt );		switch (inLicenseStatus)	{	case LicenseStatusExpiredDate:		thePrompt->SetDescriptor("\pYour license has passed its expiration date.");		break;	case LicenseStatusExpiredCount:		thePrompt->SetDescriptor("\pYour license has no analysis runs available.");		break;	case LicenseStatusExpiredBoth:		thePrompt->SetDescriptor("\pYour license has passed its expiration date and has no analysis runs available.");		break;			case LicenseStatusDateOutOfRange:		thePrompt->SetDescriptor("\pIt appears that the system clock has been set back. License is disabled.");		break;	}		// Make the dialog visible.	theDialog->Show();		bool done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{					case msg_OK: 			done = true;			break;		}	}}void CDocumentApp::HandleLicenseEntry(enum LicenseStatus inLicenseStatus, bool exitPrompt){	// Create the dialog handler.		StDialogHandler theHandler( PPob_LicenseEntryDialog, this );	// Get the dialog.	LWindow *theDialog;	theDialog = theHandler.GetDialog();	ThrowIfNil_(theDialog);		LCaption *thePrompt = dynamic_cast<LCaption*> (theDialog->FindPaneByID(kLicenseEntryPrompt));	ThrowIfNil_( thePrompt );		switch (inLicenseStatus)	{	case LicenseStatusNotInstalled:		thePrompt->SetDescriptor("\pYou must install a license to use the EyeDx software.");		break;	case LicenseStatusExpiredDate:		thePrompt->SetDescriptor("\pYour license has passed its expiration date.");		break;	case LicenseStatusExpiredCount:		thePrompt->SetDescriptor("\pYour license has no analysis runs available.");		break;	case LicenseStatusExpiredBoth:		thePrompt->SetDescriptor("\pYour license has passed its expiration date and has no analysis runs available.");		break;	case LicenseStatusDateOutOfRange:		thePrompt->SetDescriptor("\pThe system clock appears to have been set back. Setting the clock to the correct date will re-enable your license if valid");		break;	case LicenseStatusValid:		thePrompt->SetDescriptor("\pYour license is valid. You may install a new license to extend the expiration date or increase the number of analysis runs.");		break;	}		LStdButton *theCancelButton = dynamic_cast<LStdButton*> (theDialog->FindPaneByID(kLicenseEntry_Cancel));	ThrowIfNil_( theCancelButton );	LEditField *theCodeField1 = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryField1));	ThrowIfNil_( theCodeField1 );	LEditField *theCodeField2 = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryField2));	ThrowIfNil_( theCodeField2 );	LEditField *theCodeField3 = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryField3));	ThrowIfNil_( theCodeField3 );	LEditField *theCodeField4 = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryField4));	ThrowIfNil_( theCodeField4 );	LEditField *theCustomerID = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryCustomerID));	ThrowIfNil_( theCustomerID );		LEditField *theBogusField = dynamic_cast<LEditField*> (theDialog->FindPaneByID(kLicenseEntryBogusField));	ThrowIfNil_( theBogusField );		if (!exitPrompt)		theCancelButton->SetDescriptor("\pCancel");		// Make the dialog visible.	theDialog->Show();		bool done = false;	while ( !done ) 	{		// Handle dialog messages.		MessageT theMessage = theHandler.DoDialog();		switch (theMessage)		{		case msg_Cancel:					// If we were told to display "Cancel and Exit" then do the exit!			// Otherwise, just break out of the loop.			if (exitPrompt)				exit (0);			done = true;			break;					case msg_OK: 					// Here we validate the entered license. This done by concatenating the			// entered license code segments, and passing that and the customer ID to the			// license object. It will tell us if the license is valid.						bool validEntry = true;						LStr255 theBogusStr;			LStr255 theLicenseStr;			Str255 theFieldStr;						// We pretend that the bogus field has to be entered. We do this by just checking for			// a non-empty string. Of course, if they don't enter a valid value, it won't be caught.						theBogusField->GetDescriptor(theBogusStr);							// Now, validate the entered license string			theCodeField1->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);									theCodeField2->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);						theCodeField3->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);			theCodeField4->GetDescriptor(theFieldStr);			theLicenseStr.Append(theFieldStr);						// Get the customer ID and validate it						LStr255 theCustomerIDStr;						theCustomerID->GetDescriptor(theCustomerIDStr);									char custIDCStr[40];			strncpy(custIDCStr, (char *) &theCustomerIDStr[1], theCustomerIDStr[0]);			custIDCStr[theCustomerIDStr[0]] = '\0';						char licCStr[LicenseStringBufferLen];						strncpy(licCStr, (char *) &theLicenseStr[1], theLicenseStr[0]);			licCStr[theLicenseStr[0]] = '\0';						EyeDxLicenseInfo *theLicense = new EyeDxLicenseInfo();			if (!theLicense->IsValidLicenseString(licCStr))			{				::ParamText("\pInvalid license code. You must enter all four digits of each segment.", 					"\pUpper and lower case are important", Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else if (!theLicense->IsValidCustomerIDString(custIDCStr))			{				::ParamText("\pInvalid customer ID. You must enter at least 4 characters, and upper and lower case are important.", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else if (theBogusStr[0] == 0)			{				::ParamText("\pYou left the Zip/Postal Code field blank!", Str_Empty, Str_Empty, Str_Empty);				UModalAlerts::StopAlert(PPob_GeneralALRT);			}			else			{				// Decode the license TODO - this should give better feedback on exact reasons for debugging								if (!theLicense->DecodeLicense(licCStr, custIDCStr))				{					::ParamText("\pInvalid license ID.", Str_Empty, Str_Empty, Str_Empty);					UModalAlerts::StopAlert(PPob_GeneralALRT);				}				else				{					// Save the license information for future use. If a valid license is already					// installed, then try to update it. If the user is attempting to re-install					// the same license, we will get an error here, and the existing license will					// not be changed.														LicenseError theStatus = UpdateLicense(theLicense);					if (theStatus == kLicenseReuseError)					{						::ParamText("\pSorry. You cannot reuse an old license.", 									  "\pPlease obtain a new license from EyeDx, Inc.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus == kLicenseNewOlderThanInstalledError)					{						::ParamText("\pSorry. You have entered a license that has an older expiration date than the currently-installed license.", "\pPlease contact EyeDx, Inc. customer service.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus == kLicenseExpiredError)					{						::ParamText("\pSorry. You have entered an expired license.", "\pPlease obtain a new license from EyeDx, Inc.", Str_Empty, Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}					else if (theStatus != kLicenseNoError)					{						LStr255 theErrorCode = (long) theStatus;						::ParamText("\pSorry. Error ", theErrorCode,									  "\p occurred during license installation. Please contact EyeDx customer service.", Str_Empty);						UModalAlerts::StopAlert(PPob_GeneralALRT);					}							else					{						// Display a notice showing the updated license information												HandleLicenseDisplay(GetLicenseStatus());						done = true;					}				}			}						delete theLicense;		}	}}// Values used to convert the long long values into two longsconst long long kLongLongLowerMask = 0x000000000ffffffff;const long		kLongLongUpperShift = 32;LicenseError CDocumentApp::EncodeLicenseFileData(LicenseData *inLicenseData){	// We take the 	mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse	// member values and encode them into the passed data structure. We also calculate	// a checksum for the record to prevent tamering.		// Clear the structure first		memset(inLicenseData, 0, sizeof(LicenseData));	// The fields are negated before being set		inLicenseData->version = kMISCVers1;	inLicenseData->expDate = -mLicenseExpDateCode;				inLicenseData->lastUseDate = -mLicenseLastUse;	inLicenseData->availableRuns = -mLicenseCount;		inLicenseData->serialNumberLow = -(mLicenseSN & kLongLongLowerMask);	inLicenseData->serialNumberHigh = -((mLicenseSN >> kLongLongUpperShift) & kLongLongLowerMask);	inLicenseData->checksum = -(inLicenseData->version +								inLicenseData->expDate + 								inLicenseData->lastUseDate +								inLicenseData->availableRuns +								inLicenseData->serialNumberLow +								inLicenseData->serialNumberHigh);	// The other fields are zero		return kLicenseNoError;}LicenseError CDocumentApp::DecodeLicenseFileData(LicenseData *inLicenseData){	// We take the structure checksum for a valid value, and then check the individual fields	// for reasonable values. If all are reasonable, we transfer the values to the data members	// mLicenseExpDateCode, mLicenseCount, mLicenseSN, and mLicenseLastUse..		// Check the checksum. We chould be able to add up all of the fields and get zero.		long checksum = 0;		checksum = inLicenseData->checksum + inLicenseData->version +										 inLicenseData->expDate + 										 inLicenseData->lastUseDate +										 inLicenseData->availableRuns +										 inLicenseData->serialNumberLow +										 inLicenseData->serialNumberHigh;	// The other fields are zero											 	if (checksum != 0)		return kLicenseErrorNoLicense;			// The fields are negated before being set		if (inLicenseData->version != kMISCVers1)		return kLicenseErrorNoLicense;			// We check to see if the number of available runs is greater than -1 (0 is a valid number in this case) and	// less than a reasonably large number - currently 4000000.		if ((-inLicenseData->availableRuns < 0) || (-inLicenseData->availableRuns > (LicenseIncMaximum * LicenseIncMultiplier * 100)))		return kLicenseErrorNoLicense;		// Currently, we don't check the SN or date fields for validity.		mLicenseSN = ((-inLicenseData->serialNumberHigh) << kLongLongUpperShift) | (-inLicenseData->serialNumberLow);	mLicenseExpDateCode = -inLicenseData->expDate;				mLicenseLastUse = -inLicenseData->lastUseDate;		mLicenseCount = -inLicenseData->availableRuns;		return kLicenseNoError;}// This routine will check the mLicenseData member for status - either Valid,// Not Installed, or one of three Expired states (Date, Count, or Both),// and return the appropriate value. The first time through, it loads the// license information into the mLicenseData member functionLicenseStatus CDocumentApp::GetLicenseStatus(){	LicenseError theError = LoadLicense();	if (theError == kLicenseErrorNoLicense)		return LicenseStatusNotInstalled;							LicenseStatus theStatus = LicenseStatusValid;		if (mLicenseExpDateCode < EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusExpiredDate;			if (mLicenseCount == 0)	{		if (theStatus == LicenseStatusExpiredDate)			theStatus = LicenseStatusExpiredBoth;		else			theStatus = LicenseStatusExpiredCount;	}		if (mLicenseLastUse > EyeDxLicenseInfo::CreateTodayAsDateCode())		theStatus = LicenseStatusDateOutOfRange;		return theStatus;}// This routine takes a license info object pointer and extracts the count, serial number, and// expiration date from the license. It checks the serial number against the license currently// installed (if any). If the serial number in the new license is less than or equal to the// currently-installed serial number, an error is reported// and the license is not updated. Likewise, the date is also checked.// If the license passes the tests, the routine adds the count to the existing mLicenseCount field,// saves the expiration date and serial number, and then writes out the new license information.LicenseError CDocumentApp::UpdateLicense(EyeDxLicenseInfo *theLicense){	// The new license's serial number must be greater than the current one		if (mLicenseSN >= theLicense->GetSerialNumber())		return (kLicenseReuseError);		// The date codes can be directly compared, as older dates are smaller numbers.	// If for some reason they are installing a license that has an older expiration	// date than the license currently installed, that's an error.		if (mLicenseExpDateCode > theLicense->GetExpDateCode())		return (kLicenseNewOlderThanInstalledError);			// Also, the new license date code must be in the future - otherwise they are	// installing an expired license! We do allow the license to be today's date.		if (EyeDxLicenseInfo::CreateTodayAsDateCode() > theLicense->GetExpDateCode())		return (kLicenseExpiredError);	// Everything looks ok. Add the increment to the current number of available licenses.	// This number may be zero if no license is currently installed. We also save the	// new expiration date code and serial number.		mLicenseCount += theLicense->GetIncrement();	mLicenseExpDateCode = theLicense->GetExpDateCode();	mLicenseSN = theLicense->GetSerialNumber();		return (SaveLicense());}// This routine will load the mLicenseDate and mLicenseCount members from the license files// and do basic validation checking. Both license files must exist, and// the must be the same.LicenseError CDocumentApp::LoadLicense(){	LicenseData thePrimaryLicenseData;	LicenseData theBackupLicenseData;			if (mPrimaryLicense == nil)	{		// Create the primary license file object. This one takes just a filename and		// it will be created in the Preferences folder as an invisible file.				mPrimaryLicense = new CEyeDxLicenseFile(kLicenseFileName);	}		if (mBackupLicense == nil)	{		// Now, do the same for the backup file. This requires us to create a file spec		// based on the desired name and the desired folder. Currently, we use the EyeDx		// Folder.				FSSpec theBackupSpec;				::FSMakeFSSpec(mApplSpec.vRefNum, mApplSpec.parID, kLicenseFileName, &theBackupSpec);		mBackupLicense = new CEyeDxLicenseFile(theBackupSpec);	}		// Now that we have the objects, load the information. Note that we read the	// files _every_ time this routine is called to ensure that the user isn't playing	// around with the files.					mPrimaryLicense->LoadLicense(&thePrimaryLicenseData);		mBackupLicense->LoadLicense(&theBackupLicenseData);		// Ok. We now have the two license files. They have been created, and should be	// invisible. If they existed prior to these calls, the structures thePrimaryLicenseData	// and theBackupLicenseData should contain valid license information.		// There are four cases we have to deal with (failed == no license):	//	// 1. Load of primary failed but backup was ok - use the backup as the license.	// 2. Load of primary succeeded but backup failed - use the primary as the license.	// 3. Both loads failed - no license is installed.	// 4. Both loads succeeded - we just use the primary data.	//	// The SaveLicense routine will write both of the files, so they will be	// in sync at the end of this routine - we call SaveLicense.		mLicenseExpDateCode = 0;	mLicenseCount = 0;	mLicenseSN = 0;	mLicenseLastUse = 0L;		LicenseError returnVal = kLicenseNoError;	// First decode and validate the primary license. If it's ok, then we've taken care of cases	// 2 and 4 - just use the primary as the master. This routine will also fill-in the	// passed variables with the decoded values if the decoding succeeds, otherwise it will leave	// them alone.		returnVal = DecodeLicenseFileData(&thePrimaryLicenseData);		if (returnVal != kLicenseNoError)	{		// Primary is bad. This is case 1 or 3. Try decoding the backup data. If this fails, that's case 3 and there		// is no license installed. So note that, and will will write out empty data to both files.				returnVal = DecodeLicenseFileData(&theBackupLicenseData);				if (returnVal != kLicenseNoError)			returnVal = kLicenseErrorNoLicense;			else			// We have case case 1 - we'll use the backup data.			returnVal = kLicenseNoError;	}		// At this point the member data values for the license information have been loaded from the appropriate	// license file, or set to "no license" values. Both files will be updated the next time we call SaveLicense.	// We don't do that here so that we aren't always rewriting the files when we need to check the license	// status.			return returnVal;	}// This routine will write the mLicenseData member to the license filesLicenseError CDocumentApp::SaveLicense(){	LicenseData theLicenseData;		// Note the date of last use		mLicenseLastUse = EyeDxLicenseInfo::CreateTodayAsDateCode();	// Encode the data	EncodeLicenseFileData(&theLicenseData);		// Write it out to both files		mPrimaryLicense->SaveLicense(&theLicenseData);		mBackupLicense->SaveLicense(&theLicenseData);		return kLicenseNoError;}// This routine will update the mLicenseData member, and save the updated count to the// license filesLicenseError CDocumentApp::DecrementLicenseCounter(){	mLicenseCount--;	if (mLicenseCount < 0)		mLicenseCount = 0;	SaveLicense();	return kLicenseNoError;}